%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Case studies and Demos}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Supply Chain Analytics - Case Studies and Demos with Code}
\date{Oct 04, 2024}
\release{}
\author{Yossiri Adulyasak}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{docs/index::doc}}


\sphinxAtStartPar
This book, written by \sphinxhref{https://sites.google.com/site/ayossiri/home}{Yossiri Adulyasak}, is a compilation of supply chain case studies and examples, each accompanied by Python codes that demonstrate the application of machine learning, data\sphinxhyphen{}driven optimization, and analytics to supply chain applications.
This is a collection of supply chain examples and case studies with Python codes for the uses of machine learning, data\sphinxhyphen{}driven optimization and analtics for supply chain applications.

\sphinxstepscope


\part{Case studies and Demos}

\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{docs/introduction:introduction}}\label{\detokenize{docs/introduction::doc}}
\sphinxAtStartPar
This online book with code is designed to provide you with a comprehensive exploration of real\sphinxhyphen{}world applications and practical insights into the field of supply chain analytics.

\sphinxAtStartPar
Supply chain analytics has emerged as a critical discipline for businesses seeking to optimize their operations, reduce costs, and improve customer satisfaction. By leveraging data\sphinxhyphen{}driven insights, organizations can make informed decisions, identify inefficiencies, and gain a competitive edge.

\sphinxAtStartPar
Throughout this book, you will encounter a diverse collection of case studies from various industries, including manufacturing, retail, healthcare, and logistics. Each case study will delve into specific challenges faced by companies, the analytical approaches they employed, and the tangible results achieved.

\sphinxAtStartPar
By examining these real\sphinxhyphen{}world examples, you will gain a deeper understanding of how supply chain analytics can be applied to address a wide range of business problems. You will learn about the tools, techniques, and best practices that have proven successful in improving supply chain performance.

\sphinxAtStartPar
Whether you are a seasoned supply chain professional or a newcomer to the field, this book offers valuable insights and practical guidance. It is our hope that these case studies will inspire you to explore the possibilities of supply chain analytics and apply them to your own organization.


\section{Prerequisite:}
\label{\detokenize{docs/introduction:prerequisite}}
\sphinxAtStartPar
Prerequisites:

\sphinxAtStartPar
To fully grasp the concepts and techniques presented in this book, a foundational understanding of the following areas is essential:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basic Python Programming for Data Analytics:} Proficiency in Python programming is crucial for implementing the analytical models and techniques discussed. A solid grasp of fundamental Python concepts, data structures, and libraries will be invaluable. If the reader does not have a supporting meterial for this, we refer the reader to our mini\sphinxhyphen{}book “Introduction to Data Analytics with Python for Supply Chains” by Yossiri Adulyasak and Martin Cousineau and the Python tutorial available on \sphinxhref{https://www.kaggle.com/learn}{Kaggle}
author: Yossiri Adulyasak and Martin Cousineau

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Machine Learning Models:} Familiarity with machine learning algorithms is necessary for understanding and applying predictive analytics in supply chain contexts. Knowledge of regression analysis, classification, clustering, and time series forecasting will be beneficial.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Optimization Models:} A foundation in optimization models is required to explore techniques for optimizing supply chain decisions. Understanding linear programming, integer programming, and other optimization methodologies will be helpful.

\end{itemize}

\sphinxAtStartPar
If you have a solid background in these areas, you are well\sphinxhyphen{}equipped to follow this online book of supply chain analytics case studies. Throughout the book, we will delve into specific challenges faced by companies, the analytical approaches they employed, and the Python code that demonstrates how the analytics tools can be implemented. By examining these real\sphinxhyphen{}world examples, you will gain a deeper understanding of how supply chain analytics can be applied to address a wide range of business problems.

\sphinxAtStartPar
Whether you are a seasoned supply chain professional or a newcomer to the field, this book offers valuable insights and practical guidance. It is our hope that these case studies will inspire you to explore the possibilities of supply chain analytics and apply them to your own organization.


\subsection{Google Colab for Python Code}
\label{\detokenize{docs/introduction:google-colab-for-python-code}}
\sphinxAtStartPar
This course leverages Google Colab, a cloud\sphinxhyphen{}based platform for interactive computing, to facilitate your exploration of supply chain analytics concepts through code examples and demonstrations. Colab offers a user experience very similar to Jupyter Notebook (Anaconda), but with the added benefit of being free and readily accessible from any web browser. Each part of the online book includes a link that brings you direcrly to the code available in Google Colab.

\sphinxAtStartPar
A Google account is necessary to utilize Colab. You can conveniently use your Google email address to register for a free account if you haven’t already.

\sphinxAtStartPar
Accessing Colab:

\sphinxAtStartPar
Visit the Colab Website: Navigate to \sphinxurl{https://colab.research.google.com} using a preferred web browser. While most browsers are compatible, utilizing Google Chrome is recommended to ensure optimal performance and avoid potential technical issues.
Sign Up with Google Account: To begin using Colab, sign in using your Google account credentials.
Learning More about Colab:

\sphinxAtStartPar
\sphinxstylestrong{Short Introduction:} Gain a quick overview of Colab’s functionalities through this YouTube video: \sphinxurl{https://www.youtube.com/watch?v=inN8seMm7UI}
\sphinxstylestrong{Detailed Guide:} For a more comprehensive understanding of Colab, explore the official Colab notebook introduction: \sphinxurl{https://colab.research.google.com/notebooks/intro.ipynb}
By utilizing Colab, you will be able to actively participate in coding exercises and demonstrations, solidifying your grasp of supply chain analytics concepts within a practical and interactive environment.


\subsection{Python Local Installation}
\label{\detokenize{docs/introduction:python-local-installation}}
\sphinxAtStartPar
Instead of Google Colab, it is also possible to use Python locally on your machine by using Anaconda 3. Please refer to the mini\sphinxhyphen{}book “Introduction to Data Analytics with Python for Supply Chains” by Yossiri Adulyasak and Martin Cousineau or the instruction below. Anaconda is a powerful Python distribution that comes with a large collection of packages and tools that are essential for data science, machine learning, and scientific computing. Here’s a brief guide on how to install Anaconda 3:

\sphinxAtStartPar
\sphinxstylestrong{1. Download the Anaconda Installer:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Visit the official Anaconda download page: \sphinxurl{https://www.anaconda.com/download}

\item {} 
\sphinxAtStartPar
Select the appropriate installer for your operating system (Windows, macOS, or Linux).

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{2. Run the Installer:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Double\sphinxhyphen{}click the downloaded installer file.

\item {} 
\sphinxAtStartPar
Follow the on\sphinxhyphen{}screen instructions.

\item {} 
\sphinxAtStartPar
Make sure to choose the “Add Anaconda to your PATH” option during installation. This will allow you to access Anaconda commands from your terminal or command prompt.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{3. Verify Installation:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Open your terminal or command prompt.

\item {} 
\sphinxAtStartPar
Type \sphinxcode{\sphinxupquote{conda \sphinxhyphen{}\sphinxhyphen{}version}} and press Enter.

\item {} 
\sphinxAtStartPar
If Anaconda is installed correctly, you should see the installed version number.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Additional Notes:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Anaconda creates a separate environment for Python and its packages, which helps in managing different projects and avoiding conflicts between libraries.

\item {} 
\sphinxAtStartPar
You can use the \sphinxcode{\sphinxupquote{conda}} command to create, activate, and deactivate different environments.

\item {} 
\sphinxAtStartPar
For more information and advanced usage, refer to the Anaconda documentation: \sphinxurl{https://docs.anaconda.com/}

\end{itemize}

\sphinxstepscope


\chapter{Case: Retail analytics \sphinxhyphen{} Rue La La}
\label{\detokenize{docs/Case1_retails_intro:case-retail-analytics-rue-la-la}}\label{\detokenize{docs/Case1_retails_intro::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Case Reference:}
Ferreira, K. J., Lee, B. H. A., \& Simchi\sphinxhyphen{}Levi, D. (2016). Analytics for an online retailer: Demand forecasting and price optimization. Manufacturing \& service operations management, 18(1), 69\sphinxhyphen{}88.


\section{Overview of the case:}
\label{\detokenize{docs/Case1_retails_intro:overview-of-the-case}}
\sphinxAtStartPar
Rue La La, an online fashion retail company founded in 2007 in Boston, Massachusetts, specializes in offering limited\sphinxhyphen{}time sales on designer apparel and accessories. To cater to their online customers effectively, Rue La La faces several challenges in planning their product and pricing offerings. One such challenge is dealing with new products, as they lack historical data to accurately predict demand. Additionally, event factors like holidays or seasonal trends can significantly impact sales, making it difficult to forecast demand. Furthermore, the demand for one product can be influenced by the availability and pricing of competing styles, creating a complex interdependency that needs to be considered in their planning.

\sphinxAtStartPar
\sphinxstylestrong{Predictive and Prescriptive Analytics:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Predicting Demand: The company employs predictive analytics to estimate historical lost sales and forecast future demand for new products. Machine learning techniques are used to analyze factors like product attributes, seasonality, and historical sales data to predict demand.

\item {} 
\sphinxAtStartPar
Optimizing Pricing: Prescriptive analytics is employed to develop an algorithm that determines optimal pricing strategies for multiple products simultaneously. This algorithm incorporates reference price effects, considering how customers perceive prices relative to their expectations.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Modeling the Effect of Competing Products:}
The change in the price of one product can impact the demand of other similar products. As a consequence, considering the pricing policy for a product in isolation may  not result in the desired outcomes due to this cannibalization effect between similar products (i.e., competing products). This cross\sphinxhyphen{}item effect is indirectly taken into account in both the predictive and prescriptive models. More specifically, in the predictive model, the sum (or the average) of prices of all the competing products are also used as an independent variable or feature. In the prescriptive model, a constraint is imposed to enforce that the selected prices across all the competing products will be equal to the predefined value of the sum (or the average) of prices of all the competing products.

\sphinxAtStartPar
The image below (from Ferreira et al. 2018) presents an example of competing products.



\sphinxAtStartPar
The analytics workflow of Rue La La that comprises both the predictive and prescriptive analytics is depicted below.


\sphinxAtStartPar
The overall pipeline of analytics process at Rue La La is depicted below (figure from Ferreira et al. 2018)


\sphinxstepscope


\section{Demo: Simplified retail prediction pipeline for a single item}
\label{\detokenize{docs/Case1_1_Simple_Retail_Demand_Model:demo-simplified-retail-prediction-pipeline-for-a-single-item}}\label{\detokenize{docs/Case1_1_Simple_Retail_Demand_Model::doc}}
\sphinxAtStartPar
\sphinxhref{http://colab.research.google.com/github/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S8\_Simple\_Retail\_Demand\_Model.ipynb}{\sphinxstylestrong{Link to Google Colab of this Notebook}}

\sphinxAtStartPar
\sphinxstylestrong{NOTE:}
This is a simplified version of the predictive model shown in the Module 1 \sphinxhyphen{} Predictive Analytics Model. In this version, we run only the model for one item. Almost all of the parts of the codes folllow the same logic and process as the Module 1A \sphinxhref{https://colab.research.google.com/github/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S8\_Module1A\_Retail\_Demand\_Model.ipynb}{{[}Colab link for 1A{]}} but it is simplified to one product (UPC). Once you are familiar with this one, it will be easy to understand the demo 1A which consists of multiple items.

\sphinxAtStartPar
In order to continue for S9 for the optimization model, we still need to run the Module 1A. Thus, please also proceed and run the Module 1A and save the fitted models to your Google Drive or local folder.

\sphinxAtStartPar
We begin by loading the required packages.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{import} \PYG{n+nn}{sklearn}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Block 1: Data input}
\label{\detokenize{docs/Case1_1_Simple_Retail_Demand_Model:block-1-data-input}}
\sphinxAtStartPar
In addition to the original data, we add a new variable, which is the squared price (‘PRICE\_p2’).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S08\PYGZus{}09\PYGZus{}Retail\PYGZus{}Analytics/salesCereals.csv}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{salesCereals} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}
\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE\PYGZus{}p2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   Unnamed: 0 WEEK\PYGZus{}END\PYGZus{}DATE  STORE\PYGZus{}NUM         UPC  UNITS  VISITS   HHS  \PYGZbs{}
0           6    2009\PYGZhy{}01\PYGZhy{}14      367.0  1111085319   14.0    13.0  13.0   
1           8    2009\PYGZhy{}01\PYGZhy{}14      367.0  1111085350   35.0    27.0  25.0   
2          12    2009\PYGZhy{}01\PYGZhy{}14      367.0  1600027527   12.0    10.0  10.0   
3          13    2009\PYGZhy{}01\PYGZhy{}14      367.0  1600027528   31.0    26.0  19.0   
4          14    2009\PYGZhy{}01\PYGZhy{}14      367.0  1600027564   56.0    48.0  42.0   

    SPEND  PRICE  BASE\PYGZus{}PRICE  ...  DISPLAY  TPR\PYGZus{}ONLY  \PYGZbs{}
0   26.32   1.88        1.88  ...      0.0       0.0   
1   69.30   1.98        1.98  ...      0.0       0.0   
2   38.28   3.19        3.19  ...      0.0       0.0   
3  142.29   4.59        4.59  ...      0.0       0.0   
4  152.32   2.72        3.07  ...      0.0       0.0   

                       Desc     Category       Sub\PYGZhy{}Category SUMPRICE  \PYGZbs{}
0  PL HONEY NUT TOASTD OATS  COLD CEREAL  ALL FAMILY CEREAL    19.54   
1   PL BT SZ FRSTD SHRD WHT  COLD CEREAL  ALL FAMILY CEREAL    19.54   
2     GM HONEY NUT CHEERIOS  COLD CEREAL  ALL FAMILY CEREAL    19.54   
3               GM CHEERIOS  COLD CEREAL  ALL FAMILY CEREAL    19.54   
4               GM CHEERIOS  COLD CEREAL  ALL FAMILY CEREAL    19.54   

   COUNTPRICE  AVGPRICE  RELPRICE  PRICE\PYGZus{}p2  
0           7  2.791429  0.673490    3.5344  
1           7  2.791429  0.709314    3.9204  
2           7  2.791429  1.142784   10.1761  
3           7  2.791429  1.644319   21.0681  
4           7  2.791429  0.974411    7.3984  

[5 rows x 21 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
‘UPC’ stands for Universal Product Code, which can be understood as one SKU in this case and in our SCM terms in general. The code below helps us identify the SKUs by which we want to forecast and their corresponding data size (number of data instances). We can see that the number of instances for each UPC is similar and that there is no UPC with only a few data points. This is important because training a model on a small dataset may limit its generalization.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{groupby}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
            Unnamed: 0  WEEK\PYGZus{}END\PYGZus{}DATE  STORE\PYGZus{}NUM  UNITS  VISITS  HHS  SPEND  \PYGZbs{}
UPC                                                                           
1111085319         156            156        156    156     156  156    156   
1111085350         156            156        156    156     156  156    156   
1600027527         156            156        156    156     156  156    156   
1600027528         156            156        156    156     156  156    156   
1600027564         155            155        155    155     155  155    155   
3000006340         133            133        133    133     133  133    133   
3800031829         155            155        155    155     155  155    155   

            PRICE  BASE\PYGZus{}PRICE  FEATURE  DISPLAY  TPR\PYGZus{}ONLY  Desc  Category  \PYGZbs{}
UPC                                                                         
1111085319    156         156      156      156       156   156       156   
1111085350    156         156      156      156       156   156       156   
1600027527    156         156      156      156       156   156       156   
1600027528    156         156      156      156       156   156       156   
1600027564    155         155      155      155       155   155       155   
3000006340    133         133      133      133       133   133       133   
3800031829    155         155      155      155       155   155       155   

            Sub\PYGZhy{}Category  SUMPRICE  COUNTPRICE  AVGPRICE  RELPRICE  PRICE\PYGZus{}p2  
UPC                                                                           
1111085319           156       156         156       156       156       156  
1111085350           156       156         156       156       156       156  
1600027527           156       156         156       156       156       156  
1600027528           156       156         156       156       156       156  
1600027564           155       155         155       155       155       155  
3000006340           133       133         133       133       133       133  
3800031829           155       155         155       155       155       155  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 2: Feature engineering \& preparation}
\label{\detokenize{docs/Case1_1_Simple_Retail_Demand_Model:block-2-feature-engineering-preparation}}
\sphinxAtStartPar
We then organize the data by ‘UPC.’ The model presented here only runs on a predetermined subset of variables in the data. You can add or remove these explanatory variables based on your judgemental call.

\sphinxAtStartPar
Here we select only \sphinxstylestrong{one} upc to run the model.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{feature\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE\PYGZus{}p2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEATURE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DISPLAY}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TPR\PYGZus{}ONLY}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RELPRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{productList} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{upc} \PYG{o}{=} \PYG{l+m+mi}{1600027528}

\PYG{n}{X} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{n}{feature\PYGZus{}list}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UNITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
  \PYG{c+c1}{\PYGZsh{} Split into training and testing data}
\PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{X\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}test} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{model\PYGZus{}selection}\PYG{o}{.}\PYG{n}{train\PYGZus{}test\PYGZus{}split}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Block 3: Model \& algorithm (training \& testing)}
\label{\detokenize{docs/Case1_1_Simple_Retail_Demand_Model:block-3-model-algorithm-training-testing}}
\sphinxAtStartPar
In the next two cells, we train and test two different types of models, namely Linear Regression and Tree Regression. The first line in each loop is to train the model and the second line is for testing the model’s performance on unseen data. The next three lines compute the performance metrics we would like to measure. Then we compute metrics to show the performance of the model.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Linear model}

\PYG{c+c1}{\PYGZsh{} Fit the model}
\PYG{n}{regr} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{linear\PYGZus{}model}\PYG{o}{.}\PYG{n}{LinearRegression}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{,}\PYG{n}{y\PYGZus{}train}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Measure the RSME on the training set}
\PYG{n}{trainRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}train}\PYG{p}{,} \PYG{n}{regr}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Prediction on the test set}
\PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{n}{regr}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Measure the prediction performances on the test set}
\PYG{n}{testMAE} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}absolute\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)}
\PYG{n}{testMAPE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{y\PYGZus{}test} \PYG{o}{\PYGZhy{}} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)} \PYG{o}{/} \PYG{n}{y\PYGZus{}test}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{testRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Linear regression Summary \PYGZhy{} UPC:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Training RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{trainRMSE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Testing MAE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{testMAE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Testing MAPE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{testMAPE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Testing RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{testRMSE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Linear regression Summary \PYGZhy{} UPC:1600027528
Training RMSE:9.07
Testing MAE:8.09
Testing MAPE:0.25
Testing RMSE:14.07
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In order to see the impact of the price on the demand, we use a simple plot function below from mathplotlib to see how the demand would change when the price changes.

\sphinxAtStartPar
For more details of the plot function, please see: \sphinxurl{https://matplotlib.org/api/\_as\_gen/matplotlib.pyplot.plot.html}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{prices} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{2.25}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{2.75}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{3.25}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{l+m+mf}{3.75}\PYG{p}{,} \PYG{l+m+mf}{4.0}\PYG{p}{]}
\PYG{n}{input\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} generate inputs for the plot using simple feature values and varying price points}
\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{prices}\PYG{p}{:}
  \PYG{n}{input\PYGZus{}x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{,} \PYG{n}{p}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} obtain the predicted demands}
\PYG{n}{predict\PYGZus{}y} \PYG{o}{=} \PYG{n}{regr}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{input\PYGZus{}x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{,} \PYG{n}{predict\PYGZus{}y}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}ProgramData\PYGZbs{}Anaconda3\PYGZbs{}envs\PYGZbs{}sca\PYGZus{}book2\PYGZbs{}lib\PYGZbs{}site\PYGZhy{}packages\PYGZbs{}sklearn\PYGZbs{}base.py:464: UserWarning: X does not have valid feature names, but LinearRegression was fitted with feature names
  warnings.warn(
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{555b93ca89ea0299493dc25ecb2c8c7f49e603fbfe998caabd3d8eddc48d3ee5}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Likewise, we obtain the tree regression results by simply changing the function name. Here you can try the regression tree and random forest (second model) if you outcomment it.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Tree models}
\PYG{c+c1}{\PYGZsh{} regr = sklearn.tree.DecisionTreeRegressor(random\PYGZus{}state = 0).fit(X\PYGZus{}train,y\PYGZus{}train) \PYGZsh{} standard regression tree}
\PYG{n}{regr} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{ensemble}\PYG{o}{.}\PYG{n}{RandomForestRegressor}\PYG{p}{(}\PYG{n}{random\PYGZus{}state} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{,}\PYG{n}{y\PYGZus{}train}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} random forest tree}

\PYG{c+c1}{\PYGZsh{} Measure the RSME on the training set}
\PYG{n}{trainRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}train}\PYG{p}{,} \PYG{n}{regr}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Prediction on the test set}
\PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{n}{regr}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Measure the prediction performances on the test set}
\PYG{n}{testMAE} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}absolute\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)}
\PYG{n}{testMAPE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{y\PYGZus{}test} \PYG{o}{\PYGZhy{}} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)} \PYG{o}{/} \PYG{n}{y\PYGZus{}test}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{testRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tree regression Summary \PYGZhy{} UPC:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Training RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{trainRMSE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Testing MAE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{testMAE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Testing MAPE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{testMAPE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Testing RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{testRMSE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tree regression Summary \PYGZhy{} UPC:1600027528
Training RMSE:4.92
Testing MAE:8.7
Testing MAPE:0.28
Testing RMSE:14.53
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} plot to see how the results look like when changing prices}
\PYG{n}{prices} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{2.25}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{2.75}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{3.25}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{l+m+mf}{3.75}\PYG{p}{,} \PYG{l+m+mf}{4.0}\PYG{p}{]}
\PYG{n}{input\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} generate inputs for the plot using simple feature values and varying price points}
\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{prices}\PYG{p}{:}
  \PYG{n}{input\PYGZus{}x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{,} \PYG{n}{p}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{input\PYGZus{}x}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[2.0, 4.0, 0, 0, 0, 1.0],
 [2.25, 5.0625, 0, 0, 0, 1.0],
 [2.5, 6.25, 0, 0, 0, 1.0],
 [2.75, 7.5625, 0, 0, 0, 1.0],
 [3.0, 9.0, 0, 0, 0, 1.0],
 [3.25, 10.5625, 0, 0, 0, 1.0],
 [3.5, 12.25, 0, 0, 0, 1.0],
 [3.75, 14.0625, 0, 0, 0, 1.0],
 [4.0, 16.0, 0, 0, 0, 1.0]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} obtain the predicted demands}
\PYG{n}{predict\PYGZus{}y} \PYG{o}{=} \PYG{n}{regr}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{input\PYGZus{}x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{,} \PYG{n}{predict\PYGZus{}y}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}ProgramData\PYGZbs{}Anaconda3\PYGZbs{}envs\PYGZbs{}sca\PYGZus{}book2\PYGZbs{}lib\PYGZbs{}site\PYGZhy{}packages\PYGZbs{}sklearn\PYGZbs{}base.py:464: UserWarning: X does not have valid feature names, but RandomForestRegressor was fitted with feature names
  warnings.warn(
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{590fda54804623343098282dd986c11b410b05b8469ed1891982457e64c90d5d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 4: Model selection}
\label{\detokenize{docs/Case1_1_Simple_Retail_Demand_Model:block-4-model-selection}}
\sphinxAtStartPar
By comparing the average result, we can see that the linear regression model slightly outperformed the decision tree regression and did not overfit the data. In addtion, the predicted function has a better representation since the changes are monotonic (from the plots). Therefore, we proceed with the linear regression model for the whole dataset by replacing ‘X\_train’ with ‘X’. Given that the model has ‘seen’ the whole dataset, its forecast errors normally decrease. Therefore, we will save the trained model and use it for the new data which will be used in the optimization models in the next session.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Selected model}

\PYG{c+c1}{\PYGZsh{} Fit the model on the entire dataset}
\PYG{n}{regr} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{linear\PYGZus{}model}\PYG{o}{.}\PYG{n}{LinearRegression}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Prediction on the test set}
\PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{n}{regr}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Measure the prediction performances on the entire dataset}
\PYG{n}{overallMAE} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}absolute\PYGZus{}error}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)}
\PYG{n}{overallMAPE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)} \PYG{o}{/} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{overallRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Regression Summary \PYGZhy{} UPC:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Overall MAE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{overallMAE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Overall MAPE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{overallMAPE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Overall RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{overallRMSE}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Regression Summary \PYGZhy{} UPC:1600027528
Overall MAE:7.06
Overall MAPE:0.3
Overall RMSE:10.43
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Save trained models}
\label{\detokenize{docs/Case1_1_Simple_Retail_Demand_Model:save-trained-models}}
\sphinxAtStartPar
If you use Jupyter, you can save it to a local folder. The code below will put it in the current folder.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cwd} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we can save the files to the folder indicated by using the code below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} save the models to drive (here we save model only for one UPC).}
\PYG{k+kn}{import} \PYG{n+nn}{pickle}

\PYG{n}{filename} \PYG{o}{=} \PYG{n}{cwd}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}single\PYGZus{}upc\PYGZus{}demand\PYGZus{}model.sav}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} save the model to disk}
\PYG{n}{pickle}\PYG{o}{.}\PYG{n}{dump}\PYG{p}{(}\PYG{n}{regr}\PYG{p}{,} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Module 1A: Retail predictive model pipeline for multiple items}
\label{\detokenize{docs/Case1_2_Module1A_Retail_Demand_Model:module-1a-retail-predictive-model-pipeline-for-multiple-items}}\label{\detokenize{docs/Case1_2_Module1A_Retail_Demand_Model::doc}}
\sphinxAtStartPar
\sphinxhref{https://colab.research.google.com/github/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S8\_Module1A\_Retail\_Demand\_Model.ipynb}{\sphinxstylestrong{Link to Google Colab of this Notebook}}

\sphinxAtStartPar
This is the full version of the Module 1 (predictive model) which extends the simplified version of one item described previously to multiple items. Almost all of the parts of the codes folllow the same logic and process as the simplified Module 1 for one product (UPC).

\sphinxAtStartPar
We begin by loading the required packages.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{import} \PYG{n+nn}{sklearn}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{\sphinxstyleemphasis{Supplement \sphinxhyphen{} Plot functions (this is a pre\sphinxhyphen{}built plot function)}}
\label{\detokenize{docs/Case1_2_Module1A_Retail_Demand_Model:supplement-plot-functions-this-is-a-pre-built-plot-function}}
\sphinxAtStartPar
\sphinxstyleemphasis{They will be used later on for visualizations. There is no need to go through them. You only need to run the codes.}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{}See https://matplotlib.org/devdocs/gallery/subplots\PYGZus{}axes\PYGZus{}and\PYGZus{}figures/subplots\PYGZus{}demo.html}

\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}data\PYGZus{}scatter}\PYG{p}{(}\PYG{n}{data\PYGZus{}x}\PYG{p}{,} \PYG{n}{data\PYGZus{}y}\PYG{p}{,} \PYG{n}{X\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{,} \PYG{n}{feature\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Plot the results}

    \PYG{n}{n\PYGZus{}row\PYGZus{}plot} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{feature\PYGZus{}list}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} 2 plots per row}
    \PYG{n}{n\PYGZus{}col\PYGZus{}plot} \PYG{o}{=} \PYG{l+m+mi}{2}
    \PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{n\PYGZus{}row\PYGZus{}plot}\PYG{p}{,} \PYG{n}{n\PYGZus{}col\PYGZus{}plot}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{c+c1}{\PYGZsh{} column index of the plot}
    \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{c+c1}{\PYGZsh{} row index of the plot}

    \PYG{k}{for} \PYG{n}{count} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{feature\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}print(data\PYGZus{}x[:,i])}
        \PYG{n}{ax}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{data\PYGZus{}x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{feature\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}y}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{edgecolor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                    \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{darkorange}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{ax}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{feature\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                    \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{royalblue}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{prediction}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{ax}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{title}\PYG{o}{=}\PYG{n}{feature\PYGZus{}list}\PYG{p}{[}\PYG{n}{count}\PYG{p}{]}\PYG{p}{)}

        \PYG{n}{ax}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UNITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

        \PYG{n}{i} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{feature\PYGZus{}list}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n}{n\PYGZus{}col\PYGZus{}plot}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:} \PYG{n}{j} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Block 1: Data input}
\label{\detokenize{docs/Case1_2_Module1A_Retail_Demand_Model:block-1-data-input}}
\sphinxAtStartPar
In addition to the original data, we add a new variable, which is the squared price (‘PRICE\_p2’).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S08\PYGZus{}09\PYGZus{}Retail\PYGZus{}Analytics/salesCereals.csv}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{salesCereals} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}
\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE\PYGZus{}p2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   Unnamed: 0 WEEK\PYGZus{}END\PYGZus{}DATE  STORE\PYGZus{}NUM         UPC  UNITS  VISITS   HHS  \PYGZbs{}
0           6    2009\PYGZhy{}01\PYGZhy{}14      367.0  1111085319   14.0    13.0  13.0   
1           8    2009\PYGZhy{}01\PYGZhy{}14      367.0  1111085350   35.0    27.0  25.0   
2          12    2009\PYGZhy{}01\PYGZhy{}14      367.0  1600027527   12.0    10.0  10.0   
3          13    2009\PYGZhy{}01\PYGZhy{}14      367.0  1600027528   31.0    26.0  19.0   
4          14    2009\PYGZhy{}01\PYGZhy{}14      367.0  1600027564   56.0    48.0  42.0   

    SPEND  PRICE  BASE\PYGZus{}PRICE  ...  DISPLAY  TPR\PYGZus{}ONLY  \PYGZbs{}
0   26.32   1.88        1.88  ...      0.0       0.0   
1   69.30   1.98        1.98  ...      0.0       0.0   
2   38.28   3.19        3.19  ...      0.0       0.0   
3  142.29   4.59        4.59  ...      0.0       0.0   
4  152.32   2.72        3.07  ...      0.0       0.0   

                       Desc     Category       Sub\PYGZhy{}Category SUMPRICE  \PYGZbs{}
0  PL HONEY NUT TOASTD OATS  COLD CEREAL  ALL FAMILY CEREAL    19.54   
1   PL BT SZ FRSTD SHRD WHT  COLD CEREAL  ALL FAMILY CEREAL    19.54   
2     GM HONEY NUT CHEERIOS  COLD CEREAL  ALL FAMILY CEREAL    19.54   
3               GM CHEERIOS  COLD CEREAL  ALL FAMILY CEREAL    19.54   
4               GM CHEERIOS  COLD CEREAL  ALL FAMILY CEREAL    19.54   

   COUNTPRICE  AVGPRICE  RELPRICE  PRICE\PYGZus{}p2  
0           7  2.791429  0.673490    3.5344  
1           7  2.791429  0.709314    3.9204  
2           7  2.791429  1.142784   10.1761  
3           7  2.791429  1.644319   21.0681  
4           7  2.791429  0.974411    7.3984  

[5 rows x 21 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
‘UPC’ stands for Universal Product Code, which can be understood as one SKU in this case and in our SCM terms in general. The code below helps us identify the SKUs by which we want to forecast and their corresponding data size (number of data instances). We can see that the number of instances for each UPC is similar and that there is no UPC with only a few data points. This is important because training a model on a small dataset may limit its generalization.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{groupby}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
            Unnamed: 0  WEEK\PYGZus{}END\PYGZus{}DATE  STORE\PYGZus{}NUM  UNITS  VISITS  HHS  SPEND  \PYGZbs{}
UPC                                                                           
1111085319         156            156        156    156     156  156    156   
1111085350         156            156        156    156     156  156    156   
1600027527         156            156        156    156     156  156    156   
1600027528         156            156        156    156     156  156    156   
1600027564         155            155        155    155     155  155    155   
3000006340         133            133        133    133     133  133    133   
3800031829         155            155        155    155     155  155    155   

            PRICE  BASE\PYGZus{}PRICE  FEATURE  DISPLAY  TPR\PYGZus{}ONLY  Desc  Category  \PYGZbs{}
UPC                                                                         
1111085319    156         156      156      156       156   156       156   
1111085350    156         156      156      156       156   156       156   
1600027527    156         156      156      156       156   156       156   
1600027528    156         156      156      156       156   156       156   
1600027564    155         155      155      155       155   155       155   
3000006340    133         133      133      133       133   133       133   
3800031829    155         155      155      155       155   155       155   

            Sub\PYGZhy{}Category  SUMPRICE  COUNTPRICE  AVGPRICE  RELPRICE  PRICE\PYGZus{}p2  
UPC                                                                           
1111085319           156       156         156       156       156       156  
1111085350           156       156         156       156       156       156  
1600027527           156       156         156       156       156       156  
1600027528           156       156         156       156       156       156  
1600027564           155       155         155       155       155       155  
3000006340           133       133         133       133       133       133  
3800031829           155       155         155       155       155       155  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 2: Feature engineering \& preparation}
\label{\detokenize{docs/Case1_2_Module1A_Retail_Demand_Model:block-2-feature-engineering-preparation}}
\sphinxAtStartPar
We then organize the data by ‘UPC.’ The model presented here only runs on a predetermined subset of variables in the data. You can add or remove these explanatory variables based on your judgemental call.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{feature\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE\PYGZus{}p2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEATURE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DISPLAY}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TPR\PYGZus{}ONLY}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RELPRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{productList} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{productList}\PYG{p}{)}

\PYG{n}{X}\PYG{p}{,} \PYG{n}{X\PYGZus{}train}\PYG{p}{,} \PYG{n}{X\PYGZus{}test} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{y}\PYG{p}{,} \PYG{n}{y\PYGZus{}train}\PYG{p}{,} \PYG{n}{y\PYGZus{}test}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{n}{upc} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}

  \PYG{n}{X}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{n}{feature\PYGZus{}list}\PYG{p}{]}
  \PYG{n}{y}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UNITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
  \PYG{c+c1}{\PYGZsh{} Split into training and testing data}
  \PYG{n}{X\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{model\PYGZus{}selection}\PYG{o}{.}\PYG{n}{train\PYGZus{}test\PYGZus{}split}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{test\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1111085319 1111085350 1600027527 1600027528 1600027564 3000006340
 3800031829]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 3: Model \& algorithm (training \& testing)}
\label{\detokenize{docs/Case1_2_Module1A_Retail_Demand_Model:block-3-model-algorithm-training-testing}}
\sphinxAtStartPar
In the next two cells, we train and test two different types of models, namely Linear Regression and Tree Regression. In each cell, we create a loop \sphinxstylestrong{for} each UPC on the product list. The first line in each loop is to train the model and the second line is for testing the model’s performance on unseen data. The next three lines compute the performance metrics we would like to measure.

\sphinxAtStartPar
We organize the linear regression result by ‘UPC’ (row) and performance metrics (columns). Then we create a dataframe and put the computed metric in the corresponding column (the last line in each loop).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Linear model}
\PYG{n}{regr} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{regrSummary} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trainRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testMAE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testMAPE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{index} \PYG{o}{=} \PYG{n}{productList}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{upc} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
    \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{linear\PYGZus{}model}\PYG{o}{.}\PYG{n}{LinearRegression}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{trainRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{testMAE} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}absolute\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{testMAPE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{testRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{regrSummary}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=}  \PYG{p}{[}\PYG{n}{trainRMSE}\PYG{p}{,} \PYG{n}{testRMSE}\PYG{p}{,} \PYG{n}{testMAE}\PYG{p}{,} \PYG{n}{testMAPE}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Linear regression Summary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average training RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trainRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average testing RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average testing MAE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testMAE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average testing MAPE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testMAPE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Linear regression Summary
            trainRMSE   testRMSE    testMAE  testMAPE
1111085319   7.712708   8.232999   6.568929  0.838554
1111085350   7.305901   7.696171   6.135274  0.748932
1600027527  15.073315  23.519902  13.546774  0.547776
1600027528   9.073374   14.06519   8.088092  0.251657
1600027564   8.770006   6.796714   5.239537   0.27655
3000006340   4.255693   3.874297   2.886348  0.720298
3800031829   7.650327   8.518524   6.574746  0.379121
average training RMSE:8.55
average testing RMSE:10.39
average testing MAE:7.01
average testing MAPE:0.54
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we visualize the data points and the predictions using the previously defined plot function.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Plot prediction results for a product (UPC)}
\PYG{n}{upc} \PYG{o}{=} \PYG{n}{productList}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{data\PYGZus{}y} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UNITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}
\PYG{n}{data\PYGZus{}x} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{n}{feature\PYGZus{}list}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}
\PYG{n}{plot\PYGZus{}data\PYGZus{}scatter}\PYG{p}{(}\PYG{n}{data\PYGZus{}x}\PYG{p}{,} \PYG{n}{data\PYGZus{}y}\PYG{p}{,} \PYG{n}{X\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{feature\PYGZus{}list}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{e1d37ed7f3d79b90141e25009c3eb657d2a1a21b32cbc16cf22703c4cf0c7cca}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In order to see the impact of the price on the demand, we use a simple plot function below from mathplotlib to see how the demand would change when the price changes.

\sphinxAtStartPar
For more details of the plot function, please see: \sphinxurl{https://matplotlib.org/api/\_as\_gen/matplotlib.pyplot.plot.html}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{upc} \PYG{o}{=} \PYG{n}{productList}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{input\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{prices} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{2.25}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{2.75}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{3.25}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{l+m+mf}{3.75}\PYG{p}{,} \PYG{l+m+mf}{4.0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} generate inputs for the plot using simple feature values and varying price points}
\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{prices}\PYG{p}{:}
  \PYG{n}{input\PYGZus{}x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{,} \PYG{n}{p}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} obtain the predicted demands}
\PYG{n}{predict\PYGZus{}y} \PYG{o}{=} \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{input\PYGZus{}x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{,} \PYG{n}{predict\PYGZus{}y}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}ProgramData\PYGZbs{}Anaconda3\PYGZbs{}envs\PYGZbs{}sca\PYGZus{}book2\PYGZbs{}lib\PYGZbs{}site\PYGZhy{}packages\PYGZbs{}sklearn\PYGZbs{}base.py:464: UserWarning: X does not have valid feature names, but LinearRegression was fitted with feature names
  warnings.warn(
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{1ae6cd065b613a6bb9502ab74f58fa49dda9742752ba85e4b10a1eedbebe3a35}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Likewise, we obtain the tree regression results by simply changing the function name and the result table name.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Tree models}
\PYG{n}{regr} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{regrSummary} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trainRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testMAE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testMAPE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{index} \PYG{o}{=} \PYG{n}{productList}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{upc} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}

    \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{tree}\PYG{o}{.}\PYG{n}{DecisionTreeRegressor}\PYG{p}{(}\PYG{n}{random\PYGZus{}state} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} standard regression tree}
    \PYG{c+c1}{\PYGZsh{} regr[upc] = sklearn.ensemble.RandomForestRegressor(random\PYGZus{}state = 0).fit(X\PYGZus{}train[upc],y\PYGZus{}train[upc]) \PYGZsh{} random forest tree}
    \PYG{n}{trainRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}train}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{testMAE} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}absolute\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{testMAPE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{testRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{regrSummary}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=}  \PYG{p}{[}\PYG{n}{trainRMSE}\PYG{p}{,} \PYG{n}{testRMSE}\PYG{p}{,} \PYG{n}{testMAE}\PYG{p}{,} \PYG{n}{testMAPE}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Regression Tree Summary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average training RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trainRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average testing RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average testing MAE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testMAE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average testing MAPE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testMAPE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Regression Tree Summary
           trainRMSE   testRMSE    testMAE  testMAPE
1111085319  2.038099  10.759611   7.102564  0.841491
1111085350       0.0   7.471313   5.923077  0.625815
1600027527  1.147275  30.330234  15.564103  0.520292
1600027528   2.65623  13.221001   8.641026  0.286716
1600027564       0.0  10.453806   7.897436   0.38854
3000006340  0.514111   7.762087        4.5  0.992923
3800031829  1.543898   9.131518   7.487179  0.421318
average training RMSE:1.13
average testing RMSE:12.73
average testing MAE:8.16
average testing MAPE:0.58
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Plot prediction results for a product (UPC)}
\PYG{n}{upc} \PYG{o}{=} \PYG{n}{productList}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{data\PYGZus{}y} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UNITS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}
\PYG{n}{data\PYGZus{}x} \PYG{o}{=} \PYG{n}{salesCereals}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{salesCereals}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{n}{feature\PYGZus{}list}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}
\PYG{n}{plot\PYGZus{}data\PYGZus{}scatter}\PYG{p}{(}\PYG{n}{data\PYGZus{}x}\PYG{p}{,} \PYG{n}{data\PYGZus{}y}\PYG{p}{,} \PYG{n}{X\PYGZus{}test}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{feature\PYGZus{}list}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{97acc3ac154432e06ce5c0fcdaa6d0295ceaac3d2828aeb9d6d1082ab1aa7956}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{upc} \PYG{o}{=} \PYG{n}{productList}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{input\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{prices} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{2.25}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{2.75}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{3.25}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{,} \PYG{l+m+mf}{3.75}\PYG{p}{,} \PYG{l+m+mf}{4.0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} generate inputs for the plot using simple feature values and varying price points}
\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{prices}\PYG{p}{:}
  \PYG{n}{input\PYGZus{}x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{,} \PYG{n}{p}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} obtain the predicted demands}
\PYG{n}{predict\PYGZus{}y} \PYG{o}{=} \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{input\PYGZus{}x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{,} \PYG{n}{predict\PYGZus{}y}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Price}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}ProgramData\PYGZbs{}Anaconda3\PYGZbs{}envs\PYGZbs{}sca\PYGZus{}book2\PYGZbs{}lib\PYGZbs{}site\PYGZhy{}packages\PYGZbs{}sklearn\PYGZbs{}base.py:464: UserWarning: X does not have valid feature names, but DecisionTreeRegressor was fitted with feature names
  warnings.warn(
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{de89da1495854edcbea6c94d2acc2ec5744d6f3d0ecfa713b5edc5aa59a1a6d5}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 4: Model selection}
\label{\detokenize{docs/Case1_2_Module1A_Retail_Demand_Model:block-4-model-selection}}
\sphinxAtStartPar
By comparing the average result, we can see that the linear regression model generally outperformed the decision tree regression and did not overfit the data. Therefore, we proceed with the linear regression model for the whole dataset by replacing ‘X\_train’ with ‘X’. Given that the model has ‘seen’ the whole dataset, its forecast errors normally decrease. Therefore, we will save the trained model and use it for the new data which will be used in the optimization models in the next session.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Best model}
\PYG{n}{regr} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{regrSummary} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{totalMAE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{totalMAPE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{totalRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{index} \PYG{o}{=} \PYG{n}{productList}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{upc} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
    \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{linear\PYGZus{}model}\PYG{o}{.}\PYG{n}{LinearRegression}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,}\PYG{n}{y}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{testMAE} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}absolute\PYGZus{}error}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{testMAPE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{numpy}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)} \PYG{o}{/} \PYG{n}{y}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{testRMSE} \PYG{o}{=} \PYG{n}{numpy}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{mean\PYGZus{}squared\PYGZus{}error}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{regrSummary}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=}  \PYG{p}{[}\PYG{n}{testMAE}\PYG{p}{,} \PYG{n}{testMAPE}\PYG{p}{,} \PYG{n}{testRMSE}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Best Model Summary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average overall MAE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{totalMAE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average overall MAPE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{totalMAPE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{average overall RMSE:}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{regrSummary}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{totalRMSE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Best Model Summary
            totalMAE totalMAPE  totalRMSE
1111085319  6.081658  0.643456   7.756732
1111085350  5.804481      0.64   7.312385
1600027527  9.773413  0.611309  16.926391
1600027528   7.05949  0.302731  10.426074
1600027564  5.990113  0.296792   8.303061
3000006340  2.865248  0.699564   4.119918
3800031829  6.164282  0.336052   7.810234
average overall MAE:6.25
average overall MAPE:0.5
average overall RMSE:8.95
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Save trained models}
\label{\detokenize{docs/Case1_2_Module1A_Retail_Demand_Model:save-trained-models}}
\sphinxAtStartPar
If you use Jupyter, you can save it to a local folder. The code below will put it in the current folder.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cwd} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we can save the files to the folder indicated by using the code below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pickle}
\PYG{c+c1}{\PYGZsh{} save the models to the drive}
\PYG{k}{for} \PYG{n}{upc} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
    \PYG{n}{filename} \PYG{o}{=} \PYG{n}{cwd}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}demand\PYGZus{}model.sav}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{c+c1}{\PYGZsh{} save the model to disk}
    \PYG{n}{pickle}\PYG{o}{.}\PYG{n}{dump}\PYG{p}{(}\PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Module 1B: Predicting demands from trained models for decision models}
\label{\detokenize{docs/Case1_3_Module1B_Retail_Demand_Predict:module-1b-predicting-demands-from-trained-models-for-decision-models}}\label{\detokenize{docs/Case1_3_Module1B_Retail_Demand_Predict::doc}}
\sphinxAtStartPar
\sphinxhref{https://colab.research.google.com/github/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S9\_Module1B\_Retail\_Demand\_Predict.ipynb}{\sphinxstylestrong{Link to Google Colab of this Notebook}}

\sphinxAtStartPar
In Module 1A, we designed our model on a predetermined subset of regressor variables and trained it by UPC. Now in this notebook, we will prepare our inputs for the optimization model by predicting the demands based on different price points.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas}
\PYG{k+kn}{import} \PYG{n+nn}{sklearn}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{o}{*}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{1. Data input}
\label{\detokenize{docs/Case1_3_Module1B_Retail_Demand_Predict:data-input}}
\sphinxAtStartPar
We have prepared the input files which contain the features to be predicted. The first file shows a small dataset whereas the second file consists of a large dataset, i.e.,
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{‘InputFeatures\_Prob1.csv’}. This is a small scale problem. The output of this will be used in the optimization model which you will see in Modules 2A (explicit model) and 2B (compact model).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{‘InputFeatures\_Prob2.csv’}. This is a large\sphinxhyphen{}scale problem. This one contains a much higher number of variables and constraints to reflect real\sphinxhyphen{}life setting. We will use the output of this in the Module 2B.

\end{enumerate}

\sphinxAtStartPar
In order to read the input, we provide two options here. Please run only either option 1 or option 2 (\sphinxstyleemphasis{\sphinxstylestrong{not both}}).

\sphinxAtStartPar
\sphinxstylestrong{Option 1: download from the URLs}. You can you can get it directly from the URLs as usual using the codes below to download ‘InputFeatures\_Prob1.csv’ and save it in DataFrame

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} small example}
\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S08\PYGZus{}09\PYGZus{}Retail\PYGZus{}Analytics/InputFeatures\PYGZus{}Prob1.csv}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} large example, please outcomment if you want to try}
\PYG{c+c1}{\PYGZsh{} url = \PYGZsq{}https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S08\PYGZus{}09\PYGZus{}Retail\PYGZus{}Analytics/InputFeatures\PYGZus{}Prob2.csv\PYGZsq{}}

\PYG{n}{predDemand} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Dataset is now stored in a Pandas Dataframe predDemand}
\PYG{n}{predDemand}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    Unnamed: 0  avgPriceChoice         UPC  PRICE  PRICE\PYGZus{}p2  FEATURE  DISPLAY  \PYGZbs{}
0            0             3.0  1600027528    2.5      6.25        0        0   
1            1             3.0  1600027528    3.0      9.00        0        0   
2            2             3.0  1600027528    3.5     12.25        0        0   
3            3             3.0  1600027564    2.5      6.25        0        0   
4            4             3.0  1600027564    3.0      9.00        0        0   
5            5             3.0  1600027564    3.5     12.25        0        0   
6            6             3.0  3000006340    2.5      6.25        0        0   
7            7             3.0  3000006340    3.0      9.00        0        0   
8            8             3.0  3000006340    3.5     12.25        0        0   
9            9             3.0  3800031829    2.5      6.25        0        0   
10          10             3.0  3800031829    3.0      9.00        0        0   
11          11             3.0  3800031829    3.5     12.25        0        0   

    TPR\PYGZus{}ONLY  RELPRICE  
0          0  0.833333  
1          0  1.000000  
2          0  1.166667  
3          0  0.833333  
4          0  1.000000  
5          0  1.166667  
6          0  0.833333  
7          0  1.000000  
8          0  1.166667  
9          0  0.833333  
10         0  1.000000  
11         0  1.166667  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{2. Model retrieval}
\label{\detokenize{docs/Case1_3_Module1B_Retail_Demand_Predict:model-retrieval}}
\sphinxAtStartPar
Next, we retrieve the best model that we previously trained and saved from the current working directory (cmd) based on one of the two two options below.

\sphinxAtStartPar
If you model is saved on PC, you need to give the path to the saved models. Here we assume that it is located in the same folder as the notebook.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cwd} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Following the block above, we can now load the model that we previously trained and saved for each UPC.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pickle}

\PYG{n}{productList} \PYG{o}{=} \PYG{n}{predDemand}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{regr} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{upc} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
    \PYG{n}{filename} \PYG{o}{=} \PYG{n}{cwd}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}demand\PYGZus{}model.sav}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} load the model to disk}
    \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pickle}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1600027528
1600027564
3000006340
3800031829
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{3. Demand forecasting}
\label{\detokenize{docs/Case1_3_Module1B_Retail_Demand_Predict:demand-forecasting}}
\sphinxAtStartPar
In this cell, we also create a loop \sphinxstylestrong{for} each UPC. Here are the descriptions of each line in the for loop
\begin{itemize}
\item {} 
\sphinxAtStartPar
The first line in the \sphinxstylestrong{for} loop loads the data on the explanatory variables (features) for each UPC.

\item {} 
\sphinxAtStartPar
The second line retrives the UPC value so that we can call and run the model for that UPC.

\item {} 
\sphinxAtStartPar
The third line takes the model object for the current UPC (\sphinxstyleemphasis{regr{[}upc{]}}) and predicts the demand. We also use the function \sphinxstyleemphasis{clip(0.0)} to make sure that the demand is non\sphinxhyphen{}negative (which is possible since the demand is a decreasing function of price and the regression function is unbounded) and function \sphinxstyleemphasis{round(1)} to round the predicted value to one digit.

\item {} 
\sphinxAtStartPar
The fourth line put the predicted demand into the series which will be added as a new column

\end{itemize}

\sphinxAtStartPar
Once the for loop terminated, we add a new column \sphinxstyleemphasis{‘predictSales’} which shows the predicted demand.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{feature\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE\PYGZus{}p2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEATURE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DISPLAY}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TPR\PYGZus{}ONLY}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RELPRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{X} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{y\PYGZus{}pred} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} prepare blank series which will be added as a new column to the DataFrame predDemand}
\PYG{n}{predictedValueSeries} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{upc} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} Line 1 of for loop: load the data on the explanatory variable}
  \PYG{n}{X}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{predDemand}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{predDemand}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{[}\PYG{n}{feature\PYGZus{}list}\PYG{p}{]}

  \PYG{c+c1}{\PYGZsh{} Line 2: retrieve the UPC value}
  \PYG{n}{upcIndex} \PYG{o}{=} \PYG{n}{predDemand}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{predDemand}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}

  \PYG{c+c1}{\PYGZsh{} Line 3: predice the demands and make sure the demand is non\PYGZhy{}negative}
  \PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]} \PYG{o}{=} \PYG{n}{regr}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{clip}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Line 4: add the predicted demand to the series}
  \PYG{n}{predictedValueSeries} \PYG{o}{=} \PYG{n}{predictedValueSeries}\PYG{o}{.}\PYG{n}{\PYGZus{}append}\PYG{p}{(}\PYG{n}{pandas}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{y\PYGZus{}pred}\PYG{p}{[}\PYG{n}{upc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{index} \PYG{o}{=} \PYG{n}{upcIndex}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{predDemand}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{predictSales}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{predictedValueSeries}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{predDemand}\PYG{o}{.}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    Unnamed: 0  avgPriceChoice         UPC  PRICE  PRICE\PYGZus{}p2  FEATURE  DISPLAY  TPR\PYGZus{}ONLY  RELPRICE  predictSales
0            0             3.0  1600027528    2.5      6.25        0        0         0  0.833333          94.9
1            1             3.0  1600027528    3.0      9.00        0        0         0  1.000000          67.0
2            2             3.0  1600027528    3.5     12.25        0        0         0  1.166667          46.4
3            3             3.0  1600027564    2.5      6.25        0        0         0  0.833333          24.1
4            4             3.0  1600027564    3.0      9.00        0        0         0  1.000000          22.6
5            5             3.0  1600027564    3.5     12.25        0        0         0  1.166667          19.8
6            6             3.0  3000006340    2.5      6.25        0        0         0  0.833333           6.2
7            7             3.0  3000006340    3.0      9.00        0        0         0  1.000000           4.0
8            8             3.0  3000006340    3.5     12.25        0        0         0  1.166667           3.0
9            9             3.0  3800031829    2.5      6.25        0        0         0  0.833333          32.9
10          10             3.0  3800031829    3.0      9.00        0        0         0  1.000000          24.3
11          11             3.0  3800031829    3.5     12.25        0        0         0  1.166667          20.4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we save the predicted sales into csv file to be used in the optimization model later on.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Please save it as \PYGZsq{}predictedSales\PYGZus{}Prob1.csv\PYGZsq{} if \PYGZsq{}InputFeatures\PYGZus{}Prob1.csv\PYGZsq{} is used}
\PYG{c+c1}{\PYGZsh{} Otherwise, please save it as \PYGZsq{}predictedSales\PYGZus{}Prob2.csv\PYGZsq{} if \PYGZsq{}InputFeatures\PYGZus{}Prob2.csv\PYGZsq{} is used}
\PYG{n}{predDemand}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{n}{cwd} \PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{predictedSales\PYGZus{}Prob1.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Module 2A: Retail price optimization \sphinxhyphen{} Simple Explicit Model}
\label{\detokenize{docs/Case1_4_Module2A_Retail_Price_Optimization:module-2a-retail-price-optimization-simple-explicit-model}}\label{\detokenize{docs/Case1_4_Module2A_Retail_Price_Optimization::doc}}
\sphinxAtStartPar
\sphinxhref{https://colab.research.google.com/github/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S9\_Module2A\_Retail\_Price\_Optimization.ipynb}{\sphinxstylestrong{Link to Google Colab of this Notebook}}

\sphinxAtStartPar
In this part, we begin by installing the (i) Pyomo package and (ii) the linear programming solver GLPK (GNU Linear Programming Kit). Installing Pyomo and its utils in Colab is straightforward as shown below. If you wish to install them in Anaconda or in a different distribution package, please consult this page \sphinxurl{http://www.pyomo.org/installation}.

\sphinxAtStartPar
Pyomo is a modeling language which can be used in conjunction with a number of solvers. For more information on Pyomo, you can also review: \sphinxurl{http://www.pyomo.org/documentation}

\sphinxAtStartPar
The following block will take some time to process. Please wait until all the tools are sucessfully installed. This option on Colab is recommended but if you want to use an office notebook version, you can review the steps here: \sphinxurl{https://nbviewer.jupyter.org/github/jckantor/ND-Pyomo-Cookbook/blob/master/notebooks/01.01-Installing-Pyomo.ipynb\#Step-3.-Install-solvers}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Install Pyomo and GLPK in your Python environment first}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{pyomo}
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge}\PYG{p}{:}\PYG{p}{:}\PYG{n}{glpk}
\end{sphinxVerbatim}


\subsection{Blocks 1 \& 2: Data input \& input parameters}
\label{\detokenize{docs/Case1_4_Module2A_Retail_Price_Optimization:blocks-1-2-data-input-input-parameters}}
\sphinxAtStartPar
We have been working on this dataset during the past few weeks. The product list below is just simply a subset of those products. In this session, we would like to work on price optimization for the items on that list. In particular, each product can be priced at 2.5, 3.0 or 3.5 dollar and we wish to decide the prices at which these products are offered so that our total revenue is maximized. As we have learned from last week’s analysis that the relative price of competing/substitution products is a factor affecting sales, we must optimize the pricing of all these products together to reach the global optimum.

\sphinxAtStartPar
We need to prepare lists of index for products (\sphinxstyleemphasis{iIndexList}) and price options (\sphinxstyleemphasis{jIndexList}) to be used in the optimization model.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyomo}\PYG{n+nn}{.}\PYG{n+nn}{environ} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{productList} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1600027528}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1600027564}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3000006340}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3800031829}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{priceList} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{3.5}\PYG{p}{]}
\PYG{n}{avgPriceValue} \PYG{o}{=} \PYG{l+m+mf}{3.0}

\PYG{n}{iIndexList} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{productList}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{jIndexList} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{priceList}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Block 3: Create an optimization model}
\label{\detokenize{docs/Case1_4_Module2A_Retail_Price_Optimization:block-3-create-an-optimization-model}}
\sphinxAtStartPar
Now we will create an optimization model for the prescriptive pricing model of Rue La La. An optimization model consists of (i) decision variables, (ii) objective function, and (iii) constraints. You can review this page \sphinxhref{https://nbviewer.jupyter.org/github/jckantor/ND-Pyomo-Cookbook/blob/master/notebooks/02.01-Production-Models-with-Linear-Constraints.ipynb}{{[}link{]}} for a simple example of an optimization model using Pyomo.


\subsubsection{Block 3.1: Variable declarations}
\label{\detokenize{docs/Case1_4_Module2A_Retail_Price_Optimization:block-3-1-variable-declarations}}
\sphinxAtStartPar
We use \sphinxstyleemphasis{model.x} to define the decision variable of our optimization model. We will a binary variable \(x_{ij}\) which takes either the value 1 or 0 (yes/no). In other words, \(x_{ij} \in \{0,1\}\) with \(i\) being the product index and \(j\) being the price index. We can formally define this variable as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(x_{ij}\) equals 1 if the price choice \(j\) is chosen for product \(i\), 0 otherwise.

\end{itemize}

\sphinxAtStartPar
Please note that in Python (and many other programming languages), the starting index is 0. By setting \(x_{01}=1\), we sell product ‘1600027528’ (product index 0 in the product list) at price \$3.0 (price index 1 on the price list).

\sphinxAtStartPar
In this block of codes, we create an object of the model (using the \sphinxstyleemphasis{ConcreteModel} class) and declare the variable x (using \sphinxstyleemphasis{Var(iIndexList, jIndexList, within = Binary)}). The line \sphinxstyleemphasis{model.pprint()} print out the details of the entire model in the object we created. Since we only created the variables, we only see the variables in here without other components. You can visit this page \sphinxhref{https://pyomo.readthedocs.io/en/stable/pyomo\_overview/abstract\_concrete.html}{{[}Link{]}} for more details on the ConcreteModel class.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Variables}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{n}{iIndexList}\PYG{p}{,} \PYG{n}{jIndexList}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{Binary}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{pprint}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3 Set Declarations
    x\PYGZus{}index : Size=1, Index=None, Ordered=True
        Key  : Dimen : Domain              : Size : Members
        None :     2 : x\PYGZus{}index\PYGZus{}0*x\PYGZus{}index\PYGZus{}1 :   12 : \PYGZob{}(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2)\PYGZcb{}
    x\PYGZus{}index\PYGZus{}0 : Size=1, Index=None, Ordered=Insertion
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    4 : \PYGZob{}0, 1, 2, 3\PYGZcb{}
    x\PYGZus{}index\PYGZus{}1 : Size=1, Index=None, Ordered=Insertion
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    3 : \PYGZob{}0, 1, 2\PYGZcb{}

1 Var Declarations
    x : Size=12, Index=x\PYGZus{}index
        Key    : Lower : Value : Upper : Fixed : Stale : Domain
        (0, 0) :     0 :  None :     1 : False :  True : Binary
        (0, 1) :     0 :  None :     1 : False :  True : Binary
        (0, 2) :     0 :  None :     1 : False :  True : Binary
        (1, 0) :     0 :  None :     1 : False :  True : Binary
        (1, 1) :     0 :  None :     1 : False :  True : Binary
        (1, 2) :     0 :  None :     1 : False :  True : Binary
        (2, 0) :     0 :  None :     1 : False :  True : Binary
        (2, 1) :     0 :  None :     1 : False :  True : Binary
        (2, 2) :     0 :  None :     1 : False :  True : Binary
        (3, 0) :     0 :  None :     1 : False :  True : Binary
        (3, 1) :     0 :  None :     1 : False :  True : Binary
        (3, 2) :     0 :  None :     1 : False :  True : Binary

4 Declarations: x\PYGZus{}index\PYGZus{}0 x\PYGZus{}index\PYGZus{}1 x\PYGZus{}index x
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Block 3.2: Adding an objective function}
\label{\detokenize{docs/Case1_4_Module2A_Retail_Price_Optimization:block-3-2-adding-an-objective-function}}
\sphinxAtStartPar
The general form of the objective function is \(\sum_{i=0}^3 \sum_{j=0}^2 p_{j} \cdot \tilde{D}_{ijk} \cdot x_{ij}\), where \(p_{j}\) is the \(j\)th price of each product, e.g. \(p_{j=0}\) denotes the price at position 1 on the price list of a product (2.5 dollars in this case). Looking at the price list, we can easily see that \(p_{j=1}=3.0\) dollars. As we defined above, \(x_{ij}=1\) when product \(i\) is sold at price \(j\), 0 otherwise. \(\tilde{D}_{ijk}\) is the predicted sales of product \(i\) when this product is sold at price \(j\) while the average price of all competing products, including product \(i\), is equal to \(k\). In our optimization model, \(k\) is preset to 3.0 (avgPriceValue). By inputting price \(p_{j}\) and average price \(k\) into the predictive model we trained and saved last week, we can attain the corresponding predicted sales \(\left( \tilde{D}_{ijk} \right)\). We use Objective(\(\cdot\)) to define the objective function and ‘sense = maximize’ to indicate that the objective is for maximization.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Objective function}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{OBJ} \PYG{o}{=} \PYG{n}{Objective}\PYG{p}{(}\PYG{n}{sense} \PYG{o}{=} \PYG{n}{maximize}\PYG{p}{,} \PYG{n}{expr} \PYG{o}{=} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{l+m+mf}{95.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{l+m+mf}{67.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.5}\PYG{o}{*}\PYG{l+m+mf}{46.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
                      \PYG{o}{+} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{l+m+mf}{24.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{l+m+mf}{23.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.5}\PYG{o}{*}\PYG{l+m+mf}{20.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
                      \PYG{o}{+} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{l+m+mf}{6.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{l+m+mf}{4.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.5}\PYG{o}{*}\PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
                      \PYG{o}{+} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{l+m+mf}{33.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{l+m+mf}{24.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.5}\PYG{o}{*}\PYG{l+m+mf}{20.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Block 3.2: Adding constraints}
\label{\detokenize{docs/Case1_4_Module2A_Retail_Price_Optimization:block-3-2-adding-constraints}}
\sphinxAtStartPar
\sphinxstylestrong{Constraint 1: One price choice must be selected for each product}

\sphinxAtStartPar
As regards the first set of constraints, we wish to make sure that each product is sold at one price only. Therefore, the general form of this constraint set is \(\sum_{j=0}^2 x_{ij} = 1,\forall i\in\{0,1,2,3\}\). We use Constraint(\(\cdot\)) to define the constraints.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Constraints \PYGZsh{}1}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{PriceChoiceUPC1} \PYG{o}{=} \PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{PriceChoiceUPC2} \PYG{o}{=} \PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{PriceChoiceUPC3} \PYG{o}{=} \PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{PriceChoiceUPC4} \PYG{o}{=} \PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Constraint 2: The sum of the prices of all products must equal \(k\)}

\sphinxAtStartPar
The second set of constraints ensures that the average price of all the \sphinxstylestrong{4} products considered in our optimization model equals the predefined average price, which is \(k=\$3.0\times4\) (avgPriceValue x no. of products) in our model. The general form is

\sphinxAtStartPar
\( \frac{ \sum_{i=0}^3 \sum_{j=0}^2 p_{j} \cdot x_{ij} }{4} =k \iff \sum_{i=0}^3 \sum_{j=0}^2 p_{j} \cdot x_{ij} = k\cdot 4\)

\sphinxAtStartPar
This can be done using the following block.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Constraints \PYGZsh{}2}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{sumPrice} \PYG{o}{=} \PYG{n}{Constraint}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.5}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
                      \PYG{o}{+} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.5}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
                      \PYG{o}{+} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.5}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}
                      \PYG{o}{+} \PYG{l+m+mf}{2.5}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.0}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mf}{3.5}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{==} \PYG{n}{avgPriceValue}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we can print the model again to see all the components that were created.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{pprint}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3 Set Declarations
    x\PYGZus{}index : Size=1, Index=None, Ordered=True
        Key  : Dimen : Domain              : Size : Members
        None :     2 : x\PYGZus{}index\PYGZus{}0*x\PYGZus{}index\PYGZus{}1 :   12 : \PYGZob{}(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2)\PYGZcb{}
    x\PYGZus{}index\PYGZus{}0 : Size=1, Index=None, Ordered=Insertion
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    4 : \PYGZob{}0, 1, 2, 3\PYGZcb{}
    x\PYGZus{}index\PYGZus{}1 : Size=1, Index=None, Ordered=Insertion
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    3 : \PYGZob{}0, 1, 2\PYGZcb{}

1 Var Declarations
    x : Size=12, Index=x\PYGZus{}index
        Key    : Lower : Value : Upper : Fixed : Stale : Domain
        (0, 0) :     0 :  None :     1 : False :  True : Binary
        (0, 1) :     0 :  None :     1 : False :  True : Binary
        (0, 2) :     0 :  None :     1 : False :  True : Binary
        (1, 0) :     0 :  None :     1 : False :  True : Binary
        (1, 1) :     0 :  None :     1 : False :  True : Binary
        (1, 2) :     0 :  None :     1 : False :  True : Binary
        (2, 0) :     0 :  None :     1 : False :  True : Binary
        (2, 1) :     0 :  None :     1 : False :  True : Binary
        (2, 2) :     0 :  None :     1 : False :  True : Binary
        (3, 0) :     0 :  None :     1 : False :  True : Binary
        (3, 1) :     0 :  None :     1 : False :  True : Binary
        (3, 2) :     0 :  None :     1 : False :  True : Binary

1 Objective Declarations
    OBJ : Size=1, Index=None, Active=True
        Key  : Active : Sense    : Expression
        None :   True : maximize : 237.5*x[0,0] + 201.0*x[0,1] + 161.0*x[0,2] + 60.0*x[1,0] + 69.0*x[1,1] + 70.0*x[1,2] + 15.0*x[2,0] + 12.0*x[2,1] + 10.5*x[2,2] + 82.5*x[3,0] + 72.0*x[3,1] + 70.0*x[3,2]

5 Constraint Declarations
    PriceChoiceUPC1 : Size=1, Index=None, Active=True
        Key  : Lower : Body                     : Upper : Active
        None :   1.0 : x[0,0] + x[0,1] + x[0,2] :   1.0 :   True
    PriceChoiceUPC2 : Size=1, Index=None, Active=True
        Key  : Lower : Body                     : Upper : Active
        None :   1.0 : x[1,0] + x[1,1] + x[1,2] :   1.0 :   True
    PriceChoiceUPC3 : Size=1, Index=None, Active=True
        Key  : Lower : Body                     : Upper : Active
        None :   1.0 : x[2,0] + x[2,1] + x[2,2] :   1.0 :   True
    PriceChoiceUPC4 : Size=1, Index=None, Active=True
        Key  : Lower : Body                     : Upper : Active
        None :   1.0 : x[3,0] + x[3,1] + x[3,2] :   1.0 :   True
    sumPrice : Size=1, Index=None, Active=True
        Key  : Lower : Body                                                                                                                                                      : Upper : Active
        None :  12.0 : 2.5*x[0,0] + 3.0*x[0,1] + 3.5*x[0,2] + 2.5*x[1,0] + 3.0*x[1,1] + 3.5*x[1,2] + 2.5*x[2,0] + 3.0*x[2,1] + 3.5*x[2,2] + 2.5*x[3,0] + 3.0*x[3,1] + 3.5*x[3,2] :  12.0 :   True

10 Declarations: x\PYGZus{}index\PYGZus{}0 x\PYGZus{}index\PYGZus{}1 x\PYGZus{}index x OBJ PriceChoiceUPC1 PriceChoiceUPC2 PriceChoiceUPC3 PriceChoiceUPC4 sumPrice
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 4: Solution and results}
\label{\detokenize{docs/Case1_4_Module2A_Retail_Price_Optimization:block-4-solution-and-results}}
\sphinxAtStartPar
Finally, we call for the solver and obtain the solution. The first line indicates which solver we want to use and the second line solves the model (this is equivalent to \sphinxstyleemphasis{fit()} in sklearn).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solve the model}
\PYG{n}{opt} \PYG{o}{=} \PYG{n}{SolverFactory}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{glpk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}Problem\PYGZsq{}: [\PYGZob{}\PYGZsq{}Name\PYGZsq{}: \PYGZsq{}unknown\PYGZsq{}, \PYGZsq{}Lower bound\PYGZsq{}: 400.5, \PYGZsq{}Upper bound\PYGZsq{}: 400.5, \PYGZsq{}Number of objectives\PYGZsq{}: 1, \PYGZsq{}Number of constraints\PYGZsq{}: 6, \PYGZsq{}Number of variables\PYGZsq{}: 13, \PYGZsq{}Number of nonzeros\PYGZsq{}: 25, \PYGZsq{}Sense\PYGZsq{}: \PYGZsq{}maximize\PYGZsq{}\PYGZcb{}], \PYGZsq{}Solver\PYGZsq{}: [\PYGZob{}\PYGZsq{}Status\PYGZsq{}: \PYGZsq{}ok\PYGZsq{}, \PYGZsq{}Termination condition\PYGZsq{}: \PYGZsq{}optimal\PYGZsq{}, \PYGZsq{}Statistics\PYGZsq{}: \PYGZob{}\PYGZsq{}Branch and bound\PYGZsq{}: \PYGZob{}\PYGZsq{}Number of bounded subproblems\PYGZsq{}: \PYGZsq{}1\PYGZsq{}, \PYGZsq{}Number of created subproblems\PYGZsq{}: \PYGZsq{}1\PYGZsq{}\PYGZcb{}\PYGZcb{}, \PYGZsq{}Error rc\PYGZsq{}: 0, \PYGZsq{}Time\PYGZsq{}: 0.0847010612487793\PYGZcb{}], \PYGZsq{}Solution\PYGZsq{}: [OrderedDict([(\PYGZsq{}number of solutions\PYGZsq{}, 0), (\PYGZsq{}number of solutions displayed\PYGZsq{}, 0)])]\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now you can print out the solution to review using the function \sphinxstyleemphasis{model.display()} below. We can see that \(x_{00} = 1, x_{12} = 1, x_{22} = 1, x_{30} = 1\) and the optimal objective value is \(\$400.5\). In other words, we achieve the optimal revenue of \(\$400.5\) when product ‘1600027528’ is sold at price \(\$2.5\), products ‘1600027564’ and ‘3000006340’ both  at price \(\$3.5\) and product ‘3800031829’ at price \(\$2.5\). We can easily double\sphinxhyphen{}check that all the constraints are satisfied as shown in the results below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Model unknown

  Variables:
    x : Size=12, Index=x\PYGZus{}index
        Key    : Lower : Value : Upper : Fixed : Stale : Domain
        (0, 0) :     0 :   1.0 :     1 : False : False : Binary
        (0, 1) :     0 :   0.0 :     1 : False : False : Binary
        (0, 2) :     0 :   0.0 :     1 : False : False : Binary
        (1, 0) :     0 :   0.0 :     1 : False : False : Binary
        (1, 1) :     0 :   0.0 :     1 : False : False : Binary
        (1, 2) :     0 :   1.0 :     1 : False : False : Binary
        (2, 0) :     0 :   0.0 :     1 : False : False : Binary
        (2, 1) :     0 :   0.0 :     1 : False : False : Binary
        (2, 2) :     0 :   1.0 :     1 : False : False : Binary
        (3, 0) :     0 :   1.0 :     1 : False : False : Binary
        (3, 1) :     0 :   0.0 :     1 : False : False : Binary
        (3, 2) :     0 :   0.0 :     1 : False : False : Binary

  Objectives:
    OBJ : Size=1, Index=None, Active=True
        Key  : Active : Value
        None :   True : 400.5

  Constraints:
    PriceChoiceUPC1 : Size=1
        Key  : Lower : Body : Upper
        None :   1.0 :  1.0 :   1.0
    PriceChoiceUPC2 : Size=1
        Key  : Lower : Body : Upper
        None :   1.0 :  1.0 :   1.0
    PriceChoiceUPC3 : Size=1
        Key  : Lower : Body : Upper
        None :   1.0 :  1.0 :   1.0
    PriceChoiceUPC4 : Size=1
        Key  : Lower : Body : Upper
        None :   1.0 :  1.0 :   1.0
    sumPrice : Size=1
        Key  : Lower : Body : Upper
        None :  12.0 : 12.0 :  12.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Module 2B: Retail price optimization \sphinxhyphen{} Automated Implicit Model}
\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script:module-2b-retail-price-optimization-automated-implicit-model}}\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script::doc}}
\sphinxAtStartPar
\sphinxhref{https://colab.research.google.com/github/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S9\_Module2B\_Retail\_Price\_Optimization\_Script.ipynb}{\sphinxstylestrong{Link to Google Colab of this Notebook}}

\sphinxAtStartPar
This notebook is the script version of the Module2A (explicit model). Unlike the explicit model in which we need to explicitly add each complete equation one by one, we can automate the model generation process by using a script version of it. For this one, we do not expect that you understand in detail how to generate the script but simply understand what each block does. Creating the script would require some experience. The main purpose of this is to provide an example of real\sphinxhyphen{}life mathematical programming workflow which automate the prescriptive analytics process.

\sphinxAtStartPar
More particularly, we want to create an \sphinxstylestrong{implicit (or compact) model} of the following prescriptive pricing model of Rue La La.



\sphinxAtStartPar
The following blocks install Pyomo and solver. We also provide an option to use a more powerful solver \sphinxstyleemphasis{CBC} in addition to GLPK we used earlier. You can outcomment it if you want to switch to CBC.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Install Pyomo and GLPK in your Python environment first}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{pyomo}
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge}\PYG{p}{:}\PYG{p}{:}\PYG{n}{glpk}
\end{sphinxVerbatim}


\subsection{Block 1: Data input}
\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script:block-1-data-input}}
\sphinxAtStartPar
We prepared the data inputs in two files, i.e.,
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{‘predictedSales\_Prob1.csv’}. This is a small scale problem. It is identical to the problem you see in the Module 2A (explicit model).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{‘predictedSales\_Prob2.csv’}. This is a large\sphinxhyphen{}scale problem. This one contains a much higher number of variables and constraints to reflect real\sphinxhyphen{}life setting.

\end{enumerate}

\sphinxAtStartPar
Please mainly focus on the file \sphinxstyleemphasis{‘predictedSales\_Prob1.csv’} since you will get to see the same model as Module\_1A. You can also try \sphinxstyleemphasis{‘predictedSales\_Prob2.csv’} if you are interested to see the large\sphinxhyphen{}scale model.

\sphinxAtStartPar
In order to read the input, we take the file from the URL. This is the same file that you would obtain if you run the module 1B. If you want, you can change this block so that you can upload it from your PC or load it from Google Drive (see also Module 1B how these two options can be done).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas}

\PYG{c+c1}{\PYGZsh{} Prob1 is the same problem as Module 2A}
\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S08\PYGZus{}09\PYGZus{}Retail\PYGZus{}Analytics/predictedSales\PYGZus{}Prob1.csv}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Prob2 is the large\PYGZhy{}scale problem}
\PYG{c+c1}{\PYGZsh{} url = \PYGZsq{}https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S08\PYGZus{}09\PYGZus{}Retail\PYGZus{}Analytics/predictedSales\PYGZus{}Prob2.csv\PYGZsq{}}

\PYG{n}{predDemand} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Dataset is now stored in a Pandas Dataframe predDemand}
\PYG{n}{predDemand}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    NA  avgPriceChoice         UPC  PRICE  PRICE\PYGZus{}p2  FEATURE  DISPLAY  \PYGZbs{}
0    0             3.0  1600027528    2.5      6.25        0        0   
1    1             3.0  1600027528    3.0      9.00        0        0   
2    2             3.0  1600027528    3.5     12.25        0        0   
3    3             3.0  1600027564    2.5      6.25        0        0   
4    4             3.0  1600027564    3.0      9.00        0        0   
5    5             3.0  1600027564    3.5     12.25        0        0   
6    6             3.0  3000006340    2.5      6.25        0        0   
7    7             3.0  3000006340    3.0      9.00        0        0   
8    8             3.0  3000006340    3.5     12.25        0        0   
9    9             3.0  3800031829    2.5      6.25        0        0   
10  10             3.0  3800031829    3.0      9.00        0        0   
11  11             3.0  3800031829    3.5     12.25        0        0   

    TPR\PYGZus{}ONLY  RELPRICE  predictSales  
0          0  0.833333          95.0  
1          0  1.000000          67.0  
2          0  1.166667          46.0  
3          0  0.833333          24.0  
4          0  1.000000          23.0  
5          0  1.166667          20.0  
6          0  0.833333           6.0  
7          0  1.000000           4.0  
8          0  1.166667           3.0  
9          0  0.833333          33.0  
10         0  1.000000          24.0  
11         0  1.166667          20.0  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
With the new dataset, we first need to check how many average price values are there because we need to run the optimization model for each value of the average price.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{avgPriceList} \PYG{o}{=} \PYG{n}{predDemand}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avgPriceChoice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{inputColumns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avgPriceChoice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{predictSales}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Possible average price choices (k/N.Product):}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{avgPriceList}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Possible average price choices (k/N.Product):[3.]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 2: Prepare input parameters for the model}
\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script:block-2-prepare-input-parameters-for-the-model}}
\sphinxAtStartPar
We can choose which value of \(k\) we want to use in the optimization model from the \sphinxstyleemphasis{avgPriceChoice} we have in the dataset. In \sphinxstyleemphasis{‘predictedSales\_Prob1.csv’}, there is only one average price choice at \$3.0 whereas in \sphinxstyleemphasis{‘predictedSales\_Prob2.csv’} there are 4 different price choices you can choose form.

\sphinxAtStartPar
If you want to try different average price choices, we would need to repeat this procedure for each average price value and record the corresponding optimal solution to decide how each product should be priced and at which average price level to generate the optimal revenue.

\sphinxAtStartPar
Note that in this demo, we use \(p_{ij}\) instead of \(p_{j}\) since it is easier to prepare the script but the model remains identical to the Module 2A because \(p_{ij} = p_{j},i=1,...,n\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Nere we choose which value of k (avgPriceValue x N. of products) we would like to use in the model}
\PYG{c+c1}{\PYGZsh{} Note that k must be among the choices where the prediction has been prepared}
\PYG{n}{avgPriceValue} \PYG{o}{=}  \PYG{n}{avgPriceList}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Now we select only the row which corresponds to the previously chosen value of avgPriceValue (again k = avgPriceValue x N. of products)}
\PYG{n}{predDemand\PYGZus{}k} \PYG{o}{=} \PYG{n}{predDemand}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{predDemand}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avgPriceChoice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{avgPriceValue}\PYG{p}{]}\PYG{p}{[}\PYG{n}{inputColumns}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{predDemand\PYGZus{}k}\PYG{p}{)}
\PYG{n}{productList} \PYG{o}{=} \PYG{n}{predDemand\PYGZus{}k}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{priceList} \PYG{o}{=} \PYG{n}{predDemand\PYGZus{}k}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Here we prepare the dictionary to be used in the optimization model}
\PYG{n}{p} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{D} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{n}{upc} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{price} \PYG{o+ow}{in} \PYG{n}{priceList}\PYG{p}{:}
    \PYG{n}{p}\PYG{p}{[}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{,}\PYG{n}{price}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{price}
    \PYG{n}{D}\PYG{p}{[}\PYG{p}{(}\PYG{n}{upc}\PYG{p}{,}\PYG{n}{price}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{predDemand\PYGZus{}k}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{(}\PYG{n}{predDemand}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{UPC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{upc}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{predDemand\PYGZus{}k}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PRICE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{price}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{predictSales}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{D}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    avgPriceChoice         UPC  PRICE  predictSales
0              3.0  1600027528    2.5          95.0
1              3.0  1600027528    3.0          67.0
2              3.0  1600027528    3.5          46.0
3              3.0  1600027564    2.5          24.0
4              3.0  1600027564    3.0          23.0
5              3.0  1600027564    3.5          20.0
6              3.0  3000006340    2.5           6.0
7              3.0  3000006340    3.0           4.0
8              3.0  3000006340    3.5           3.0
9              3.0  3800031829    2.5          33.0
10             3.0  3800031829    3.0          24.0
11             3.0  3800031829    3.5          20.0
\PYGZob{}(1600027528, 2.5): 2.5, (1600027528, 3.0): 3.0, (1600027528, 3.5): 3.5, (1600027564, 2.5): 2.5, (1600027564, 3.0): 3.0, (1600027564, 3.5): 3.5, (3000006340, 2.5): 2.5, (3000006340, 3.0): 3.0, (3000006340, 3.5): 3.5, (3800031829, 2.5): 2.5, (3800031829, 3.0): 3.0, (3800031829, 3.5): 3.5\PYGZcb{}
\PYGZob{}(1600027528, 2.5): 95.0, (1600027528, 3.0): 67.0, (1600027528, 3.5): 46.0, (1600027564, 2.5): 24.0, (1600027564, 3.0): 23.0, (1600027564, 3.5): 20.0, (3000006340, 2.5): 6.0, (3000006340, 3.0): 4.0, (3000006340, 3.5): 3.0, (3800031829, 2.5): 33.0, (3800031829, 3.0): 24.0, (3800031829, 3.5): 20.0\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 3: Create an optimization model}
\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script:block-3-create-an-optimization-model}}

\subsubsection{Block 3.1: Variable declarations}
\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script:block-3-1-variable-declarations}}
\sphinxAtStartPar
Unlike the first part of today’s session, we index the decision variables and demand parameters by the product and the price themselves rather than their index. Indeed, we previously denoted \(x_{ij}=1\) if the price option \(j\) is chosen for product \(i\), and 0 otherwise. Now, our variable is denoted by \(x_{1600027528,\ 3.0}=1\), which means that product UPC ‘1600027528’ will be sold at 3.0 dollars. The same notational remark applies to predicted demand (\(D_{ijk}\)) for the sum of prices \(k\) and price (\(p_{ij}\)) parameters. We can declare the constraint sets first (model.PriceChoiceUPC, model.sumPrice) and then \sphinxstylestrong{add} the constraint functions later.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyomo}\PYG{n+nn}{.}\PYG{n+nn}{environ} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{iIndexList} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{productList}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{jIndexList} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{priceList}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Variables}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{n}{productList}\PYG{p}{,} \PYG{n}{priceList}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{Binary}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Constraints}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{PriceChoiceUPC} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{sumPrice} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Print to review the model (equations are still not included)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{pprint}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5 Set Declarations
    PriceChoiceUPC\PYGZus{}index : Size=1, Index=None, Ordered=Insertion
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    0 :      \PYGZob{}\PYGZcb{}
    sumPrice\PYGZus{}index : Size=1, Index=None, Ordered=Insertion
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    0 :      \PYGZob{}\PYGZcb{}
    x\PYGZus{}index : Size=1, Index=None, Ordered=False
        Key  : Dimen : Domain              : Size : Members
        None :     2 : x\PYGZus{}index\PYGZus{}0*x\PYGZus{}index\PYGZus{}1 :   12 : \PYGZob{}(1600027528, 2.5), (1600027528, 3.0), (1600027528, 3.5), (1600027564, 2.5), (1600027564, 3.0), (1600027564, 3.5), (3000006340, 2.5), (3000006340, 3.0), (3000006340, 3.5), (3800031829, 2.5), (3800031829, 3.0), (3800031829, 3.5)\PYGZcb{}
    x\PYGZus{}index\PYGZus{}0 : Size=1, Index=None, Ordered=False
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    4 : \PYGZob{}1600027528, 1600027564, 3000006340, 3800031829\PYGZcb{}
    x\PYGZus{}index\PYGZus{}1 : Size=1, Index=None, Ordered=False
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    3 : \PYGZob{}2.5, 3.0, 3.5\PYGZcb{}

1 Var Declarations
    x : Size=12, Index=x\PYGZus{}index
        Key               : Lower : Value : Upper : Fixed : Stale : Domain
        (1600027528, 2.5) :     0 :  None :     1 : False :  True : Binary
        (1600027528, 3.0) :     0 :  None :     1 : False :  True : Binary
        (1600027528, 3.5) :     0 :  None :     1 : False :  True : Binary
        (1600027564, 2.5) :     0 :  None :     1 : False :  True : Binary
        (1600027564, 3.0) :     0 :  None :     1 : False :  True : Binary
        (1600027564, 3.5) :     0 :  None :     1 : False :  True : Binary
        (3000006340, 2.5) :     0 :  None :     1 : False :  True : Binary
        (3000006340, 3.0) :     0 :  None :     1 : False :  True : Binary
        (3000006340, 3.5) :     0 :  None :     1 : False :  True : Binary
        (3800031829, 2.5) :     0 :  None :     1 : False :  True : Binary
        (3800031829, 3.0) :     0 :  None :     1 : False :  True : Binary
        (3800031829, 3.5) :     0 :  None :     1 : False :  True : Binary

2 Constraint Declarations
    PriceChoiceUPC : Size=0, Index=PriceChoiceUPC\PYGZus{}index, Active=True
        Key : Lower : Body : Upper : Active
    sumPrice : Size=0, Index=sumPrice\PYGZus{}index, Active=True
        Key : Lower : Body : Upper : Active

8 Declarations: x\PYGZus{}index\PYGZus{}0 x\PYGZus{}index\PYGZus{}1 x\PYGZus{}index x PriceChoiceUPC\PYGZus{}index PriceChoiceUPC sumPrice\PYGZus{}index sumPrice
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Block 3.2: Adding an objective function}
\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script:block-3-2-adding-an-objective-function}}
\sphinxAtStartPar
Instead of iteratively entering the value for each price and predicted sales, we can simply create a loop \sphinxstylestrong{for} each product and a loop \sphinxstylestrong{for} each price. The code now looks very much like the general equation \(\sum_{i} \sum_{j} p_{ij} \cdot D_{ijk} \cdot x_{ij}\) we saw in the first part of today’s session with some minor changes for notational simplification.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Objective function}

\PYG{n}{obj\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{D}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{productList} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{priceList}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{obj\PYGZus{}expr}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{OBJ} \PYG{o}{=} \PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{obj\PYGZus{}expr}\PYG{p}{,} \PYG{n}{sense} \PYG{o}{=} \PYG{n}{maximize}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
237.5*x[1600027528,2.5] + 201.0*x[1600027528,3.0] + 161.0*x[1600027528,3.5] + 60.0*x[1600027564,2.5] + 69.0*x[1600027564,3.0] + 70.0*x[1600027564,3.5] + 15.0*x[3000006340,2.5] + 12.0*x[3000006340,3.0] + 10.5*x[3000006340,3.5] + 82.5*x[3800031829,2.5] + 72.0*x[3800031829,3.0] + 70.0*x[3800031829,3.5]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Block 3.3: Adding constraints}
\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script:block-3-3-adding-constraints}}
\sphinxAtStartPar
\sphinxstylestrong{Constraint 1: One price choice must be selected for each product}

\sphinxAtStartPar
Similarly, we can create a loop to \sphinxstylestrong{add} constraint functions to the constraint set \sphinxstylestrong{for} each product to ensure that only one price on the list is selected for that product. Unlike the first part of today’s session, we need not iteratively type each constraint.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Constraints \PYGZsh{}1}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
  \PYG{n}{const1\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{priceList}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{const1\PYGZus{}expr}\PYG{p}{)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{PriceChoiceUPC}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const1\PYGZus{}expr}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x[1600027528,2.5] + x[1600027528,3.0] + x[1600027528,3.5]  ==  1
x[1600027564,2.5] + x[1600027564,3.0] + x[1600027564,3.5]  ==  1
x[3000006340,2.5] + x[3000006340,3.0] + x[3000006340,3.5]  ==  1
x[3800031829,2.5] + x[3800031829,3.0] + x[3800031829,3.5]  ==  1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Constraint 2: The sum of the prices of all products must equal \(k\)}

\sphinxAtStartPar
Similar \sphinxstylestrong{for} loops apply to the average price constraint. Please refer to the first part of today’s session for detailed elaboration.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Constraints \PYGZsh{}2}
\PYG{n}{const2\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{productList} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{priceList}\PYG{p}{)} \PYG{o}{==} \PYG{n}{avgPriceValue}\PYG{o}{*}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{productList}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{const2\PYGZus{}expr}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{sumPrice}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const2\PYGZus{}expr}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2.5*x[1600027528,2.5] + 3.0*x[1600027528,3.0] + 3.5*x[1600027528,3.5] + 2.5*x[1600027564,2.5] + 3.0*x[1600027564,3.0] + 3.5*x[1600027564,3.5] + 2.5*x[3000006340,2.5] + 3.0*x[3000006340,3.0] + 3.5*x[3000006340,3.5] + 2.5*x[3800031829,2.5] + 3.0*x[3800031829,3.0] + 3.5*x[3800031829,3.5]  ==  12.0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}pyomo.core.base.constraint.\PYGZus{}GeneralConstraintData at 0x2590bd2c580\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We can print the model to review prior to solving it.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{pprint}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5 Set Declarations
    PriceChoiceUPC\PYGZus{}index : Size=1, Index=None, Ordered=Insertion
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    4 : \PYGZob{}1, 2, 3, 4\PYGZcb{}
    sumPrice\PYGZus{}index : Size=1, Index=None, Ordered=Insertion
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    1 :    \PYGZob{}1,\PYGZcb{}
    x\PYGZus{}index : Size=1, Index=None, Ordered=False
        Key  : Dimen : Domain              : Size : Members
        None :     2 : x\PYGZus{}index\PYGZus{}0*x\PYGZus{}index\PYGZus{}1 :   12 : \PYGZob{}(1600027528, 2.5), (1600027528, 3.0), (1600027528, 3.5), (1600027564, 2.5), (1600027564, 3.0), (1600027564, 3.5), (3000006340, 2.5), (3000006340, 3.0), (3000006340, 3.5), (3800031829, 2.5), (3800031829, 3.0), (3800031829, 3.5)\PYGZcb{}
    x\PYGZus{}index\PYGZus{}0 : Size=1, Index=None, Ordered=False
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    4 : \PYGZob{}1600027528, 1600027564, 3000006340, 3800031829\PYGZcb{}
    x\PYGZus{}index\PYGZus{}1 : Size=1, Index=None, Ordered=False
        Key  : Dimen : Domain : Size : Members
        None :     1 :    Any :    3 : \PYGZob{}2.5, 3.0, 3.5\PYGZcb{}

1 Var Declarations
    x : Size=12, Index=x\PYGZus{}index
        Key               : Lower : Value : Upper : Fixed : Stale : Domain
        (1600027528, 2.5) :     0 :  None :     1 : False :  True : Binary
        (1600027528, 3.0) :     0 :  None :     1 : False :  True : Binary
        (1600027528, 3.5) :     0 :  None :     1 : False :  True : Binary
        (1600027564, 2.5) :     0 :  None :     1 : False :  True : Binary
        (1600027564, 3.0) :     0 :  None :     1 : False :  True : Binary
        (1600027564, 3.5) :     0 :  None :     1 : False :  True : Binary
        (3000006340, 2.5) :     0 :  None :     1 : False :  True : Binary
        (3000006340, 3.0) :     0 :  None :     1 : False :  True : Binary
        (3000006340, 3.5) :     0 :  None :     1 : False :  True : Binary
        (3800031829, 2.5) :     0 :  None :     1 : False :  True : Binary
        (3800031829, 3.0) :     0 :  None :     1 : False :  True : Binary
        (3800031829, 3.5) :     0 :  None :     1 : False :  True : Binary

1 Objective Declarations
    OBJ : Size=1, Index=None, Active=True
        Key  : Active : Sense    : Expression
        None :   True : maximize : 237.5*x[1600027528,2.5] + 201.0*x[1600027528,3.0] + 161.0*x[1600027528,3.5] + 60.0*x[1600027564,2.5] + 69.0*x[1600027564,3.0] + 70.0*x[1600027564,3.5] + 15.0*x[3000006340,2.5] + 12.0*x[3000006340,3.0] + 10.5*x[3000006340,3.5] + 82.5*x[3800031829,2.5] + 72.0*x[3800031829,3.0] + 70.0*x[3800031829,3.5]

2 Constraint Declarations
    PriceChoiceUPC : Size=4, Index=PriceChoiceUPC\PYGZus{}index, Active=True
        Key : Lower : Body                                                      : Upper : Active
          1 :   1.0 : x[1600027528,2.5] + x[1600027528,3.0] + x[1600027528,3.5] :   1.0 :   True
          2 :   1.0 : x[1600027564,2.5] + x[1600027564,3.0] + x[1600027564,3.5] :   1.0 :   True
          3 :   1.0 : x[3000006340,2.5] + x[3000006340,3.0] + x[3000006340,3.5] :   1.0 :   True
          4 :   1.0 : x[3800031829,2.5] + x[3800031829,3.0] + x[3800031829,3.5] :   1.0 :   True
    sumPrice : Size=1, Index=sumPrice\PYGZus{}index, Active=True
        Key : Lower : Body                                                                                                                                                                                                                                                                                          : Upper : Active
          1 :  12.0 : 2.5*x[1600027528,2.5] + 3.0*x[1600027528,3.0] + 3.5*x[1600027528,3.5] + 2.5*x[1600027564,2.5] + 3.0*x[1600027564,3.0] + 3.5*x[1600027564,3.5] + 2.5*x[3000006340,2.5] + 3.0*x[3000006340,3.0] + 3.5*x[3000006340,3.5] + 2.5*x[3800031829,2.5] + 3.0*x[3800031829,3.0] + 3.5*x[3800031829,3.5] :  12.0 :   True

9 Declarations: x\PYGZus{}index\PYGZus{}0 x\PYGZus{}index\PYGZus{}1 x\PYGZus{}index x PriceChoiceUPC\PYGZus{}index PriceChoiceUPC sumPrice\PYGZus{}index sumPrice OBJ
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 4: Solution and results}
\label{\detokenize{docs/Case1_5_Module2B_Retail_Price_Optimization_Script:block-4-solution-and-results}}
\sphinxAtStartPar
Finally, we call the solver and obtain the optimal solution. We can see that product ‘1600027528’ is also sold at price \(\$2.5\), products ‘1600027564’ and ‘3000006340’ both  at price \(\$3.5\) and product ‘3800031829’ at price \(\$2.5\), but the optimal objective value is now \(\$399.3\). The objective function value is slightly different from the Module\_2A but the solution (values of \(x\)) is the same. This is due to the fact that we keep more digits in this example.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solve the model}
\PYG{n}{opt} \PYG{o}{=} \PYG{n}{SolverFactory}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{glpk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Model unknown

  Variables:
    x : Size=12, Index=x\PYGZus{}index
        Key               : Lower : Value : Upper : Fixed : Stale : Domain
        (1600027528, 2.5) :     0 :   1.0 :     1 : False : False : Binary
        (1600027528, 3.0) :     0 :   0.0 :     1 : False : False : Binary
        (1600027528, 3.5) :     0 :   0.0 :     1 : False : False : Binary
        (1600027564, 2.5) :     0 :   0.0 :     1 : False : False : Binary
        (1600027564, 3.0) :     0 :   0.0 :     1 : False : False : Binary
        (1600027564, 3.5) :     0 :   1.0 :     1 : False : False : Binary
        (3000006340, 2.5) :     0 :   0.0 :     1 : False : False : Binary
        (3000006340, 3.0) :     0 :   0.0 :     1 : False : False : Binary
        (3000006340, 3.5) :     0 :   1.0 :     1 : False : False : Binary
        (3800031829, 2.5) :     0 :   1.0 :     1 : False : False : Binary
        (3800031829, 3.0) :     0 :   0.0 :     1 : False : False : Binary
        (3800031829, 3.5) :     0 :   0.0 :     1 : False : False : Binary

  Objectives:
    OBJ : Size=1, Index=None, Active=True
        Key  : Active : Value
        None :   True : 400.5

  Constraints:
    PriceChoiceUPC : Size=4
        Key : Lower : Body : Upper
          1 :   1.0 :  1.0 :   1.0
          2 :   1.0 :  1.0 :   1.0
          3 :   1.0 :  1.0 :   1.0
          4 :   1.0 :  1.0 :   1.0
    sumPrice : Size=1
        Key : Lower : Body : Upper
          1 :  12.0 : 12.0 :  12.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Case: Online fulfillment \sphinxhyphen{} US online retail}
\label{\detokenize{docs/Case2_online_fulfillment:case-online-fulfillment-us-online-retail}}\label{\detokenize{docs/Case2_online_fulfillment::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Case Reference:}
Acimovic, J., \& Graves, S. C. (2015). Making better fulfillment decisions on the fly in an online retail environment. Manufacturing \& Service Operations Management, 17(1), 34\sphinxhyphen{}51.


\section{Overview of the case:}
\label{\detokenize{docs/Case2_online_fulfillment:overview-of-the-case}}
\sphinxAtStartPar
This case describes how an online retail company uses a combination of techniques to optimize their fulfillment decisions in an online fashion and reduce outbound shipping costs.

\sphinxAtStartPar
\sphinxstylestrong{Challenges Faced by the Company}

\sphinxAtStartPar
The company faces two main challenges in its online retail operations:

\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{} Myopic Fulfillment Decisions:} The company’s current approach to fulfilling orders is myopic, meaning they consider only the cheapest shipping option for each order based on their current inventory position, without considering potential future costs. This can lead to higher overall shipping costs in the long run.\\
\sphinxstylestrong{\sphinxhyphen{} Inventory Management:} The company needs to effectively manage inventory levels across multiple fulfillment centers (FCs) to avoid stockouts while minimizing holding costs.

\sphinxAtStartPar
\sphinxstylestrong{Solution Approach:}

\sphinxAtStartPar
The research paper proposes a solution that leverages both approximate dynamic programming and linear programming to address these challenges.

\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{} Approximate Dynamic Programming:} A heuristic is developed based on approximate dynamic programming to make fulfillment decisions in an online fashion for each order recieved. This heuristic considers not only the immediate shipping cost of fulfilling an order from a particular FC, but also the estimated future shipping costs based on the impact on future inventory levels.

\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{} Linear Programming (LP):} An LP model is used to anticipate the future costs based on a future inventory position that is the result of the fulfillment decision (i.e., which fulfillment center(s) to fulfill this current order received) by considering the antipicated demands and inventory positions across all FCs. Rather than solving a large number of LPs, a calculation derived from the dual values of the LP, can be used to determine which fulfillment center should be used for the current order to minimize the current and future shipping costs.

\sphinxAtStartPar
\sphinxstylestrong{Reduced Shipping Costs}

\sphinxAtStartPar
The proposed approach helps reduce outbound shipping costs by making more strategic fulfillment decisions. Here’s how it achieves that:

\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{}Forward\sphinxhyphen{}Looking Decisions:} By considering the impact of current fulfillment decisions on future inventory levels and shipping costs, the heuristic can choose options that minimize overall shipping costs over time, rather than just focusing on the cheapest option for the immediate order.

\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{}Inventory Optimization:} The LP\sphinxhyphen{}based approach helps identify opportunities to better allocate inventory across FCs, potentially reducing the need for expensive expedited shipments in the future.

\sphinxAtStartPar
The case mentions that the company has implemented the proposed heuristic and achieved a reduction in outbound shipping costs on the order of 1\%, while capturing 36\% of the potential opportunity for improvement. These results suggest that the approach can generate significant cost savings for the company.

\sphinxstepscope


\section{Demo: Online Fulfillment}
\label{\detokenize{docs/Case2_1_Module1_Online_Fulfillment_Script:demo-online-fulfillment}}\label{\detokenize{docs/Case2_1_Module1_Online_Fulfillment_Script::doc}}
\sphinxAtStartPar
In this demo, we also begin by installing the (i) Pyomo package and (ii) the linear programming solver GLPK (GNU Linear Programming Kit). Please feel free to revisit \sphinxhref{https://github.com/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S9\_Module2A\_Retail\_Price\_Optimization.ipynb}{the previous notebook} for further information.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Install Pyomo and GLPK in your Python environment if it is not already done.}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{pyomo}
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge}\PYG{p}{:}\PYG{p}{:}\PYG{n}{glpk}
\end{sphinxVerbatim}


\subsection{Blocks 1\&2: Data input and parameters}
\label{\detokenize{docs/Case2_1_Module1_Online_Fulfillment_Script:blocks-1-2-data-input-and-parameters}}
\sphinxAtStartPar
We have two different datasets, but their structures are the same. The dataset 1 is the same as in the paper whereas the dataset 2 is a larger dataset to demonstrate how data can be adapted.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Fulfillment center (FC) data}: each dataset contains a set of fulfillment centers \(FC\) (\sphinxstyleemphasis{listFC}), each of which has a given level of inventory \({\bf X}\) (\sphinxstyleemphasis{inventoryFC}). Customers can place an order for either a single item or multiple items, but if no fulfillment center has all the items available, the retailer has to resort to split deliveries, which obviously affect the shipping expenses. Therefore, our optimization model has to take account of the probability that the fulfillment center has ‘other items in order’ (\sphinxstyleemphasis{probMultiAvailability}).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Customer region data}: each customer zone (\sphinxstyleemphasis{listRegion}) has to be associated with a certain demand over the next \(\tau\) days (\sphinxstyleemphasis{demandValue}) for customer \(j\) and the proportion of orders that are for multiple items (\sphinxstyleemphasis{probMultiItem}).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Shipment cost data}: \sphinxstyleemphasis{costSingle\([i,j]\)} denotes the cost of a single delivery from Fulfillment Center (FC) \sphinxstyleemphasis{i} to Customer Zone \sphinxstyleemphasis{j} or \(c_{ij}\). Please note that for Data 1, since there is only one customer zone (Kansas), there is only one cost from each origin (i.e., from FC \sphinxstyleemphasis{i} to Kansas). \sphinxstyleemphasis{avgNoMultiItem} stands for the \sphinxstyleemphasis{average number of items in a multi\sphinxhyphen{}item order}. This will help us compute the average shipping cost per item for multi\sphinxhyphen{}item orders. More specifically \(\omega = 1/\mbox{avgNoMultiItem}\).

\end{enumerate}

\sphinxAtStartPar
The first set of parameters \sphinxstylestrong{Data 1} corresponds to the example provided in the case below (Figure from Acimovic and Graves, 2015).



\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Data 1 (same as in the paper)}

\PYG{c+c1}{\PYGZsh{} Fulfillment center (FC) data}
\PYG{n}{listFC} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Utah}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Nevada}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{inventoryFC} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{inventoryFC}\PYG{p}{)}
\PYG{n}{probMultiAvailability} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{probMultiAvailability}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Customer region data}
\PYG{n}{listRegion} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Kansas}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{demandValue} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{listRegion}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{demandValue}\PYG{p}{)}
\PYG{n}{probMultiItem} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{listRegion}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.75}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{probMultiItem}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Shipment cost data}
\PYG{n}{costSingle} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{costSingle}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} average number of items in a multi\PYGZhy{}item order}
\PYG{n}{avgNoMultiItem} \PYG{o}{=} \PYG{l+m+mf}{3.0}
\PYG{c+c1}{\PYGZsh{} we can calculate the multi\PYGZhy{}item shipping discount \PYGZdl{}\PYGZbs{}omega\PYGZdl{}}
\PYG{n}{shippingDiscount} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{avgNoMultiItem}

\PYG{c+c1}{\PYGZsh{} Prepare shipment cost above in dictionary format}
\PYG{n}{costSingleDict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{listRegion}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{costSingleDict}\PYG{p}{[}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{listRegion}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{costSingle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{costSingleDict}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}Utah\PYGZsq{}: 5, \PYGZsq{}Nevada\PYGZsq{}: 20\PYGZcb{}
\PYGZob{}\PYGZsq{}Utah\PYGZsq{}: 0.5, \PYGZsq{}Nevada\PYGZsq{}: 0.2\PYGZcb{}
\PYGZob{}\PYGZsq{}Kansas\PYGZsq{}: 20\PYGZcb{}
\PYGZob{}\PYGZsq{}Kansas\PYGZsq{}: 0.75\PYGZcb{}
[[9], [12]]
\PYGZob{}(\PYGZsq{}Utah\PYGZsq{}, \PYGZsq{}Kansas\PYGZsq{}): 9, (\PYGZsq{}Nevada\PYGZsq{}, \PYGZsq{}Kansas\PYGZsq{}): 12\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Data 2}

\PYG{c+c1}{\PYGZsh{} Fulfillment center (FC) data}
\PYG{n}{listFC} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Delta\PYGZhy{}BC}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Brampton\PYGZhy{}ON}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ottawa\PYGZhy{}ON}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{inventoryFC} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{inventoryFC}\PYG{p}{)}
\PYG{n}{probMultiAvailability} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.32}\PYG{p}{,} \PYG{l+m+mf}{0.45}\PYG{p}{,} \PYG{l+m+mf}{0.17}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{probMultiAvailability}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Customer region data}
\PYG{n}{listRegion} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Toronto}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Montreal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Calgary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Vancouver}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{demandValue} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{listRegion}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{33}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{demandValue}\PYG{p}{)}
\PYG{n}{probMultiItem} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{listRegion}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.73}\PYG{p}{,} \PYG{l+m+mf}{0.68}\PYG{p}{,} \PYG{l+m+mf}{0.54}\PYG{p}{,} \PYG{l+m+mf}{0.64}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{probMultiItem}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Shipment cost data}
\PYG{n}{costSingle} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{24.5}\PYG{p}{,} \PYG{l+m+mf}{25.5}\PYG{p}{,} \PYG{l+m+mf}{18.1}\PYG{p}{,} \PYG{l+m+mf}{12.3}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mf}{13.6}\PYG{p}{,} \PYG{l+m+mf}{17.5}\PYG{p}{,} \PYG{l+m+mf}{22.8}\PYG{p}{,} \PYG{l+m+mf}{23.6}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mf}{18.1}\PYG{p}{,} \PYG{l+m+mf}{14.1}\PYG{p}{,} \PYG{l+m+mf}{21.1}\PYG{p}{,} \PYG{l+m+mf}{22.8}\PYG{p}{]}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} average number of items in a multi\PYGZhy{}item order}
\PYG{n}{avgNoMultiItem} \PYG{o}{=} \PYG{l+m+mf}{2.5}
\PYG{c+c1}{\PYGZsh{} we can calculate the multi\PYGZhy{}item shipping discount \PYGZdl{}\PYGZbs{}omega\PYGZdl{}}
\PYG{n}{shippingDiscount} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{avgNoMultiItem}

\PYG{c+c1}{\PYGZsh{} Prepare shipment cost above in dictionary format}
\PYG{n}{costSingleDict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{listRegion}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{costSingleDict}\PYG{p}{[}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{listRegion}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{costSingle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{costSingleDict}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}: 37, \PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}: 85, \PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}: 25\PYGZcb{}
\PYGZob{}\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}: 0.32, \PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}: 0.45, \PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}: 0.17\PYGZcb{}
\PYGZob{}\PYGZsq{}Toronto\PYGZsq{}: 45, \PYGZsq{}Montreal\PYGZsq{}: 27, \PYGZsq{}Calgary\PYGZsq{}: 15, \PYGZsq{}Vancouver\PYGZsq{}: 33\PYGZcb{}
\PYGZob{}\PYGZsq{}Toronto\PYGZsq{}: 0.73, \PYGZsq{}Montreal\PYGZsq{}: 0.68, \PYGZsq{}Calgary\PYGZsq{}: 0.54, \PYGZsq{}Vancouver\PYGZsq{}: 0.64\PYGZcb{}
\PYGZob{}(\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}): 24.5, (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}): 25.5, (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}): 18.1, (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}): 12.3, (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}): 13.6, (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}): 17.5, (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}): 22.8, (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}): 23.6, (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}): 18.1, (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}): 14.1, (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}): 21.1, (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}): 22.8\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Block 3: Create an optimization model}
\label{\detokenize{docs/Case2_1_Module1_Online_Fulfillment_Script:block-3-create-an-optimization-model}}

\subsubsection{Block 3.1: Variable declarations}
\label{\detokenize{docs/Case2_1_Module1_Online_Fulfillment_Script:block-3-1-variable-declarations}}
\sphinxAtStartPar
As we all learned in \sphinxhref{https://github.com/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S9\_Module2A\_Retail\_Price\_Optimization.ipynb}{Retail Analytics Case}, an optimization model consists of (i) decision variables, (ii) objective function, and (iii) constraints.

\sphinxAtStartPar
Our decision variables include model.x, model.y and model.w, which are all nonnegative, denoting the flow from FC \sphinxstyleemphasis{i} to customer region \sphinxstyleemphasis{j}. In particular,

\sphinxAtStartPar
model.\sphinxstylestrong{x}\([i, j]\) (or \(x_{ij}\)) denotes the decision variable for \sphinxstylestrong{unsplit} flow from FC \sphinxstyleemphasis{i} to \sphinxstylestrong{multi\sphinxhyphen{}item} customer \sphinxstyleemphasis{j}. The unit cost of this flow is \(\omega c_{ij}\);

\sphinxAtStartPar
model.\sphinxstylestrong{y}\([i, j]\) (or \(y_{ij}\)) denotes the decision variable for \sphinxstylestrong{split} flow from FC \sphinxstyleemphasis{i} to \sphinxstylestrong{multi\sphinxhyphen{}item} customer \sphinxstyleemphasis{j}. The unit cost of this flow is \(2\omega c_{ij}\) (two shipments are used if the order cannot be shipped in one shipment);

\sphinxAtStartPar
model.\sphinxstylestrong{w}\([i, j]\) (or \(w_{ij}\)) denotes the decision variable for flow from FC \sphinxstyleemphasis{i} to \sphinxstylestrong{single\sphinxhyphen{}item} customer \sphinxstyleemphasis{j}.  The unit cost of this flow is \(c_{ij}\).

\sphinxAtStartPar
On the last line, we also create an object to store the shadow prices (dual variables). This is used if we don’t want to solve the LP multiple times.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyomo}\PYG{n+nn}{.}\PYG{n+nn}{environ} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Variables}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{,} \PYG{n}{listRegion}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{NonNegativeReals}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{,} \PYG{n}{listRegion}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{NonNegativeReals}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{w} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{n}{listFC}\PYG{p}{,} \PYG{n}{listRegion}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{NonNegativeReals}\PYG{p}{)}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{inventoryOnHand} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{demandSingle} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{demandMulitiple} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{maxMultiShipment} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create an object to access to shadow prices. Please note that the codes must be exactly written as}
\PYG{c+c1}{\PYGZsh{} model.dual = Suffix(direction=Suffix.IMPORT\PYGZus{}EXPORT) in order for it to work because it was hard coded in pyomo.}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{dual} \PYG{o}{=} \PYG{n}{Suffix}\PYG{p}{(}\PYG{n}{direction}\PYG{o}{=}\PYG{n}{Suffix}\PYG{o}{.}\PYG{n}{IMPORT\PYGZus{}EXPORT}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsubsection{Block 3.2: Objective function}
\label{\detokenize{docs/Case2_1_Module1_Online_Fulfillment_Script:block-3-2-objective-function}}
\sphinxAtStartPar
For notational simplication, let

\sphinxAtStartPar
\(c_{ij}=\) costSingle\([i,j]\), the cost of a single delivery from Fulfillment Center (FC) \sphinxstyleemphasis{i} to Customer Zone \sphinxstyleemphasis{j};

\sphinxAtStartPar
\(\omega=1\) / avgNoMultiItem, expected discount of sending multi\sphinxhyphen{}item order in one package.

\sphinxAtStartPar
Then, we have the general form of the objective function as follows
\begin{equation*}
\begin{split}\min\limits_{x,y,w} \left\{ \sum_{i\in\mathcal{FC}} \sum_{j\in\mathcal{J}}\left(  c_{ij}\cdot w_{ij} + \omega \cdot c_{ij}\cdot x_{ij} + 2\omega \cdot c_{ij}\cdot y_{ij} \right) \right\}\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Objective function}

\PYG{n}{obj\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{costSingleDict}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{+} \PYG{n}{shippingDiscount}\PYG{o}{*}\PYG{n}{costSingleDict}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYGZbs{}
               \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{shippingDiscount}\PYG{p}{)}\PYG{o}{*}\PYG{n}{costSingleDict}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{listFC} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{listRegion}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{obj\PYGZus{}expr}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{OBJ} \PYG{o}{=} \PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{obj\PYGZus{}expr}\PYG{p}{,} \PYG{n}{sense} \PYG{o}{=} \PYG{n}{minimize}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
24.5*w[Delta\PYGZhy{}BC,Toronto] + 9.8*x[Delta\PYGZhy{}BC,Toronto] + 19.6*y[Delta\PYGZhy{}BC,Toronto] + 25.5*w[Delta\PYGZhy{}BC,Montreal] + 10.200000000000001*x[Delta\PYGZhy{}BC,Montreal] + 20.400000000000002*y[Delta\PYGZhy{}BC,Montreal] + 18.1*w[Delta\PYGZhy{}BC,Calgary] + 7.240000000000001*x[Delta\PYGZhy{}BC,Calgary] + 14.480000000000002*y[Delta\PYGZhy{}BC,Calgary] + 12.3*w[Delta\PYGZhy{}BC,Vancouver] + 4.920000000000001*x[Delta\PYGZhy{}BC,Vancouver] + 9.840000000000002*y[Delta\PYGZhy{}BC,Vancouver] + 13.6*w[Brampton\PYGZhy{}ON,Toronto] + 5.44*x[Brampton\PYGZhy{}ON,Toronto] + 10.88*y[Brampton\PYGZhy{}ON,Toronto] + 17.5*w[Brampton\PYGZhy{}ON,Montreal] + 7.0*x[Brampton\PYGZhy{}ON,Montreal] + 14.0*y[Brampton\PYGZhy{}ON,Montreal] + 22.8*w[Brampton\PYGZhy{}ON,Calgary] + 9.120000000000001*x[Brampton\PYGZhy{}ON,Calgary] + 18.240000000000002*y[Brampton\PYGZhy{}ON,Calgary] + 23.6*w[Brampton\PYGZhy{}ON,Vancouver] + 9.440000000000001*x[Brampton\PYGZhy{}ON,Vancouver] + 18.880000000000003*y[Brampton\PYGZhy{}ON,Vancouver] + 18.1*w[Ottawa\PYGZhy{}ON,Toronto] + 7.240000000000001*x[Ottawa\PYGZhy{}ON,Toronto] + 14.480000000000002*y[Ottawa\PYGZhy{}ON,Toronto] + 14.1*w[Ottawa\PYGZhy{}ON,Montreal] + 5.640000000000001*x[Ottawa\PYGZhy{}ON,Montreal] + 11.280000000000001*y[Ottawa\PYGZhy{}ON,Montreal] + 21.1*w[Ottawa\PYGZhy{}ON,Calgary] + 8.440000000000001*x[Ottawa\PYGZhy{}ON,Calgary] + 16.880000000000003*y[Ottawa\PYGZhy{}ON,Calgary] + 22.8*w[Ottawa\PYGZhy{}ON,Vancouver] + 9.120000000000001*x[Ottawa\PYGZhy{}ON,Vancouver] + 18.240000000000002*y[Ottawa\PYGZhy{}ON,Vancouver]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Block 3.3: Constraints functions}
\label{\detokenize{docs/Case2_1_Module1_Online_Fulfillment_Script:block-3-3-constraints-functions}}
\sphinxAtStartPar
\sphinxstylestrong{Constraint Set 1}: Inventory availability at FC \sphinxstyleemphasis{i}

\sphinxAtStartPar
This set of constraints ensures that the total demand (orders) assigned to FC \sphinxstyleemphasis{i} is less than or equal to the inventory at FC \sphinxstyleemphasis{i}.

\sphinxAtStartPar
Let \(X_i\) denote the inventory level at FC \sphinxstyleemphasis{i} and \(\mathcal{FC}\) denote the list of all FCs.
\$\(\sum_{j\in\mathcal{J}} \left( w_{ij} + x_{ij} + y_{ij} \right) \leq X_i, \forall i\in \mathcal{FC} \)\$

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Constraints 1 Inventory availability at FC i}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{listFC}\PYG{p}{:}
  \PYG{n}{const\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{listRegion}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{inventoryFC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{const\PYGZus{}expr}\PYG{p}{)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{inventoryOnHand}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const\PYGZus{}expr}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
w[Delta\PYGZhy{}BC,Toronto] + x[Delta\PYGZhy{}BC,Toronto] + y[Delta\PYGZhy{}BC,Toronto] + w[Delta\PYGZhy{}BC,Montreal] + x[Delta\PYGZhy{}BC,Montreal] + y[Delta\PYGZhy{}BC,Montreal] + w[Delta\PYGZhy{}BC,Calgary] + x[Delta\PYGZhy{}BC,Calgary] + y[Delta\PYGZhy{}BC,Calgary] + w[Delta\PYGZhy{}BC,Vancouver] + x[Delta\PYGZhy{}BC,Vancouver] + y[Delta\PYGZhy{}BC,Vancouver]  \PYGZlt{}=  37
w[Brampton\PYGZhy{}ON,Toronto] + x[Brampton\PYGZhy{}ON,Toronto] + y[Brampton\PYGZhy{}ON,Toronto] + w[Brampton\PYGZhy{}ON,Montreal] + x[Brampton\PYGZhy{}ON,Montreal] + y[Brampton\PYGZhy{}ON,Montreal] + w[Brampton\PYGZhy{}ON,Calgary] + x[Brampton\PYGZhy{}ON,Calgary] + y[Brampton\PYGZhy{}ON,Calgary] + w[Brampton\PYGZhy{}ON,Vancouver] + x[Brampton\PYGZhy{}ON,Vancouver] + y[Brampton\PYGZhy{}ON,Vancouver]  \PYGZlt{}=  85
w[Ottawa\PYGZhy{}ON,Toronto] + x[Ottawa\PYGZhy{}ON,Toronto] + y[Ottawa\PYGZhy{}ON,Toronto] + w[Ottawa\PYGZhy{}ON,Montreal] + x[Ottawa\PYGZhy{}ON,Montreal] + y[Ottawa\PYGZhy{}ON,Montreal] + w[Ottawa\PYGZhy{}ON,Calgary] + x[Ottawa\PYGZhy{}ON,Calgary] + y[Ottawa\PYGZhy{}ON,Calgary] + w[Ottawa\PYGZhy{}ON,Vancouver] + x[Ottawa\PYGZhy{}ON,Vancouver] + y[Ottawa\PYGZhy{}ON,Vancouver]  \PYGZlt{}=  25
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Constraint Set 2}: Future demand for single\sphinxhyphen{}item order in region \sphinxstyleemphasis{j}

\sphinxAtStartPar
This set of constraints ensures that the single\sphinxhyphen{}item demand at Customer (Demand) Zone \sphinxstyleemphasis{j} is satisfied.

\sphinxAtStartPar
Let \(D_j\) denote the demand at Customer Zone \sphinxstyleemphasis{j}, \(\mathcal{J}\) denote the list of all Customer (Demand) Zones and \(\lambda_j\) denote the proportion of orders that are for multiple items (probMultiItem) \(\Rightarrow\left(1-\lambda_j\right)\) equals the proportion of orders that are for a single item.
\$\(\sum_{i \in \mathcal{FC}} w_{ij} = D_j \cdot \left( 1-\lambda_j \right), \forall j\in \mathcal{J} \)\$

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Constraints 2 Future demand for single\PYGZhy{}item order in region j}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{listRegion}\PYG{p}{:}
  \PYG{n}{const\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{w}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{listFC}\PYG{p}{)} \PYG{o}{==} \PYG{n}{demandValue}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{probMultiItem}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{const\PYGZus{}expr}\PYG{p}{)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{demandSingle}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const\PYGZus{}expr}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
w[Delta\PYGZhy{}BC,Toronto] + w[Brampton\PYGZhy{}ON,Toronto] + w[Ottawa\PYGZhy{}ON,Toronto]  ==  12.15
w[Delta\PYGZhy{}BC,Montreal] + w[Brampton\PYGZhy{}ON,Montreal] + w[Ottawa\PYGZhy{}ON,Montreal]  ==  8.639999999999999
w[Delta\PYGZhy{}BC,Calgary] + w[Brampton\PYGZhy{}ON,Calgary] + w[Ottawa\PYGZhy{}ON,Calgary]  ==  6.8999999999999995
w[Delta\PYGZhy{}BC,Vancouver] + w[Brampton\PYGZhy{}ON,Vancouver] + w[Ottawa\PYGZhy{}ON,Vancouver]  ==  11.879999999999999
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Constraint Set 3}: Future demand for multi\sphinxhyphen{}item order in region \sphinxstyleemphasis{j}

\sphinxAtStartPar
This set of constraints ensures that the multi\sphinxhyphen{}item demand at Customer (Demand) Zone \sphinxstyleemphasis{j} is satisfied.

\sphinxAtStartPar
Using the similar notations as in \sphinxstyleemphasis{Constraint set 2}, we attain
\$\(\sum_{i \in \mathcal{FC}}  \left( x_{ij} + y_{ij} \right) = D_j \cdot \lambda_j, \forall j\in \mathcal{J} \)\$

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Constraints 3 Future demand for multi\PYGZhy{}item order in region j}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{listRegion}\PYG{p}{:}
  \PYG{n}{const\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{+} \PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{listFC}\PYG{p}{)} \PYG{o}{==} \PYG{n}{demandValue}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{probMultiItem}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{const\PYGZus{}expr}\PYG{p}{)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{demandMulitiple}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const\PYGZus{}expr}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x[Delta\PYGZhy{}BC,Toronto] + y[Delta\PYGZhy{}BC,Toronto] + x[Brampton\PYGZhy{}ON,Toronto] + y[Brampton\PYGZhy{}ON,Toronto] + x[Ottawa\PYGZhy{}ON,Toronto] + y[Ottawa\PYGZhy{}ON,Toronto]  ==  32.85
x[Delta\PYGZhy{}BC,Montreal] + y[Delta\PYGZhy{}BC,Montreal] + x[Brampton\PYGZhy{}ON,Montreal] + y[Brampton\PYGZhy{}ON,Montreal] + x[Ottawa\PYGZhy{}ON,Montreal] + y[Ottawa\PYGZhy{}ON,Montreal]  ==  18.360000000000003
x[Delta\PYGZhy{}BC,Calgary] + y[Delta\PYGZhy{}BC,Calgary] + x[Brampton\PYGZhy{}ON,Calgary] + y[Brampton\PYGZhy{}ON,Calgary] + x[Ottawa\PYGZhy{}ON,Calgary] + y[Ottawa\PYGZhy{}ON,Calgary]  ==  8.100000000000001
x[Delta\PYGZhy{}BC,Vancouver] + y[Delta\PYGZhy{}BC,Vancouver] + x[Brampton\PYGZhy{}ON,Vancouver] + y[Brampton\PYGZhy{}ON,Vancouver] + x[Ottawa\PYGZhy{}ON,Vancouver] + y[Ottawa\PYGZhy{}ON,Vancouver]  ==  21.12
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Constraint Set 4}: Estimated maximum number multi\sphinxhyphen{}item shipments from FC \sphinxstyleemphasis{i} to customer region \sphinxstyleemphasis{j}

\sphinxAtStartPar
It should be noted that unsplit delivery for a multi\sphinxhyphen{}item order from FC \sphinxstyleemphasis{i} to Customer Region \sphinxstyleemphasis{j} is effected only when FC \sphinxstyleemphasis{i} has ‘other items in order’. Let \(\rho_i\) denote the probability that FC \sphinxstyleemphasis{i} has ‘other items in order’ (probMultiAvailability). Then, we impose the following constraints.
\begin{equation*}
\begin{split} x_{ij} \leq D_j \cdot \lambda_j \cdot \rho_i, \forall i\in\mathcal{FC}, j\in \mathcal{J} \end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Constraints \PYGZsh{}4 Estimated maximum number multi\PYGZhy{}item shipments from FC i to customer regions j}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{listFC}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{listRegion}\PYG{p}{:}
    \PYG{n}{const\PYGZus{}expr} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{x}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{demandValue}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{probMultiItem}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{probMultiAvailability}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{const\PYGZus{}expr}\PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{maxMultiShipment}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const\PYGZus{}expr}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x[Delta\PYGZhy{}BC,Toronto]  \PYGZlt{}=  10.512
x[Delta\PYGZhy{}BC,Montreal]  \PYGZlt{}=  5.875200000000001
x[Delta\PYGZhy{}BC,Calgary]  \PYGZlt{}=  2.5920000000000005
x[Delta\PYGZhy{}BC,Vancouver]  \PYGZlt{}=  6.758400000000001
x[Brampton\PYGZhy{}ON,Toronto]  \PYGZlt{}=  14.7825
x[Brampton\PYGZhy{}ON,Montreal]  \PYGZlt{}=  8.262000000000002
x[Brampton\PYGZhy{}ON,Calgary]  \PYGZlt{}=  3.645000000000001
x[Brampton\PYGZhy{}ON,Vancouver]  \PYGZlt{}=  9.504000000000001
x[Ottawa\PYGZhy{}ON,Toronto]  \PYGZlt{}=  5.5845
x[Ottawa\PYGZhy{}ON,Montreal]  \PYGZlt{}=  3.121200000000001
x[Ottawa\PYGZhy{}ON,Calgary]  \PYGZlt{}=  1.3770000000000004
x[Ottawa\PYGZhy{}ON,Vancouver]  \PYGZlt{}=  3.5904000000000003
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can print the entire model to check if you want

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This is commented so that we won\PYGZsq{}t print out unless necessary. You can outcomment to print it.}
\PYG{c+c1}{\PYGZsh{} model.pprint()}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Block 4: Solution and results}
\label{\detokenize{docs/Case2_1_Module1_Online_Fulfillment_Script:block-4-solution-and-results}}
\sphinxAtStartPar
Finally, we call for the solver and obtain the solution. The first line indicates which solver we want to use and the second line solves the model (this is equivalent to \sphinxstyleemphasis{fit()} in sklearn). The last line \sphinxstyleemphasis{displays} the solution.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Solve the model}
\PYG{n}{opt} \PYG{o}{=} \PYG{n}{SolverFactory}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{glpk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Model unknown

  Variables:
    x : Size=12, Index=x\PYGZus{}index
        Key                          : Lower : Value   : Upper : Fixed : Stale : Domain
          (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 :   3.645 :  None : False : False : NonNegativeReals
         (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :   8.262 :  None : False : False : NonNegativeReals
          (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 : 14.7825 :  None : False : False : NonNegativeReals
        (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 :   9.504 :  None : False : False : NonNegativeReals
             (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 :   2.592 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :  5.8752 :  None : False : False : NonNegativeReals
             (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 :  1.2412 :  None : False : False : NonNegativeReals
           (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 :  6.7584 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 :   1.377 :  None : False : False : NonNegativeReals
           (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :  3.1212 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 :  5.5845 :  None : False : False : NonNegativeReals
          (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 :  3.5904 :  None : False : False : NonNegativeReals
    y : Size=12, Index=y\PYGZus{}index
        Key                          : Lower : Value             : Upper : Fixed : Stale : Domain
          (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 :               0.0 :  None : False : False : NonNegativeReals
         (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :               0.0 :  None : False : False : NonNegativeReals
          (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 :           11.2418 :  None : False : False : NonNegativeReals
        (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 :               0.0 :  None : False : False : NonNegativeReals
             (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 : 0.485999999999999 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :               0.0 :  None : False : False : NonNegativeReals
             (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 :               0.0 :  None : False : False : NonNegativeReals
           (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 :            1.2672 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 :               0.0 :  None : False : False : NonNegativeReals
           (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :            1.1016 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 :               0.0 :  None : False : False : NonNegativeReals
          (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 :               0.0 :  None : False : False : NonNegativeReals
    w : Size=12, Index=w\PYGZus{}index
        Key                          : Lower : Value : Upper : Fixed : Stale : Domain
          (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 :   0.0 :  None : False : False : NonNegativeReals
         (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :   0.0 :  None : False : False : NonNegativeReals
          (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 : 12.15 :  None : False : False : NonNegativeReals
        (\PYGZsq{}Brampton\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 :   0.0 :  None : False : False : NonNegativeReals
             (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 :   6.9 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :   0.0 :  None : False : False : NonNegativeReals
             (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 :   0.0 :  None : False : False : NonNegativeReals
           (\PYGZsq{}Delta\PYGZhy{}BC\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 : 11.88 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Calgary\PYGZsq{}) :     0 :   0.0 :  None : False : False : NonNegativeReals
           (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Montreal\PYGZsq{}) :     0 :  8.64 :  None : False : False : NonNegativeReals
            (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Toronto\PYGZsq{}) :     0 :   0.0 :  None : False : False : NonNegativeReals
          (\PYGZsq{}Ottawa\PYGZhy{}ON\PYGZsq{}, \PYGZsq{}Vancouver\PYGZsq{}) :     0 :   0.0 :  None : False : False : NonNegativeReals

  Objectives:
    OBJ : Size=1, Index=None, Active=True
        Key  : Active : Value
        None :   True : 1200.042204

  Constraints:
    inventoryOnHand : Size=3
        Key : Lower : Body               : Upper
          1 :  None :  37.00000000000001 :  37.0
          2 :  None : 59.585300000000004 :  85.0
          3 :  None :            23.4147 :  25.0
    demandSingle : Size=4
        Key : Lower              : Body  : Upper
          1 :              12.15 : 12.15 :              12.15
          2 :  8.639999999999999 :  8.64 :  8.639999999999999
          3 : 6.8999999999999995 :   6.9 : 6.8999999999999995
          4 : 11.879999999999999 : 11.88 : 11.879999999999999
    demandMulitiple : Size=4
        Key : Lower              : Body               : Upper
          1 :              32.85 :              32.85 :              32.85
          2 : 18.360000000000003 : 18.360000000000003 : 18.360000000000003
          3 :  8.100000000000001 :                8.1 :  8.100000000000001
          4 :              21.12 :              21.12 :              21.12
    maxMultiShipment : Size=12
        Key : Lower : Body    : Upper
          1 :  None :  1.2412 :             10.512
          2 :  None :  5.8752 :  5.875200000000001
          3 :  None :   2.592 : 2.5920000000000005
          4 :  None :  6.7584 :  6.758400000000001
          5 :  None : 14.7825 :            14.7825
          6 :  None :   8.262 :  8.262000000000002
          7 :  None :   3.645 :  3.645000000000001
          8 :  None :   9.504 :  9.504000000000001
          9 :  None :  5.5845 :             5.5845
         10 :  None :  3.1212 :  3.121200000000001
         11 :  None :   1.377 : 1.3770000000000004
         12 :  None :  3.5904 : 3.5904000000000003
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In order to quickly determine the approximate cost\sphinxhyphen{}to\sphinxhyphen{}go without solving multiple times the LP model above, we can also make use of the shadow price. The codes below print out the shadow prices of all the constraints. Only the shadow prices of the constraint \sphinxstyleemphasis{inventoryOnHand} are used to calculate the approximate cost\sphinxhyphen{}to\sphinxhyphen{}go, i.e., \$\(C_{k}({\bf X_k})=\min_{i\in \mathcal{FC}}\left({c_{ik}+C_{k+1}({\bf X_{k+1}})}\right)=\min_{i\in \mathcal{FC}}\left({c_{ik}+C_{k+1}({\bf X_{k}})-\pi_{i}}\right).\)\$

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Obtain reduced cost for each constraint}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{dual}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
dual : Direction=Suffix.IMPORT\PYGZus{}EXPORT, Datatype=Suffix.FLOAT
    Key                  : Value
      demandMulitiple[1] :                 10.88
      demandMulitiple[2] :                 11.28
      demandMulitiple[3] :                 15.56
      demandMulitiple[4] :                 10.92
         demandSingle[1] :                  13.6
         demandSingle[2] :                  14.1
         demandSingle[3] :                 19.18
         demandSingle[4] :                 13.38
      inventoryOnHand[1] :                 \PYGZhy{}1.08
      inventoryOnHand[2] :                   0.0
      inventoryOnHand[3] :                   0.0
    maxMultiShipment[10] :                 \PYGZhy{}5.64
    maxMultiShipment[11] :                 \PYGZhy{}7.12
    maxMultiShipment[12] :                  \PYGZhy{}1.8
     maxMultiShipment[1] :                   0.0
     maxMultiShipment[2] : \PYGZhy{}1.77635683940025e\PYGZhy{}15
     maxMultiShipment[3] :                 \PYGZhy{}7.24
     maxMultiShipment[4] :                 \PYGZhy{}4.92
     maxMultiShipment[5] :                 \PYGZhy{}5.44
     maxMultiShipment[6] :                 \PYGZhy{}4.28
     maxMultiShipment[7] :                 \PYGZhy{}6.44
     maxMultiShipment[8] :                 \PYGZhy{}1.48
     maxMultiShipment[9] :                 \PYGZhy{}3.64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Case: Disruption Analytics \sphinxhyphen{} Ford Motor}
\label{\detokenize{docs/Case3_disruption_analytics:case-disruption-analytics-ford-motor}}\label{\detokenize{docs/Case3_disruption_analytics::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Case Reference:}
Simchi\sphinxhyphen{}Levi, D., Schmidt, W., Wei, Y., Zhang, P.Y., Combs, K., Ge, Y., Gusikhin, O., Sanders, M. and Zhang, D., 2015. Identifying risks and mitigating disruptions in the automotive supply chain. INFORMS Journal on Applied Analytics, 45(5), pp.375\sphinxhyphen{}390.




\section{Overview of the case:}
\label{\detokenize{docs/Case3_disruption_analytics:overview-of-the-case}}
\sphinxAtStartPar
This case outlines the challenges faced by disruption risk analytics models in the context of a large automaker like Ford. These challenges include the rarity of disruptive events, which makes it difficult to gather sufficient data for accurate modeling. Additionally, risk assessment often involves subjective judgments, leading to potential biases in the analysis. The scale and complexity of Ford’s global supply chain further complicate the task of developing effective models to anticipate and mitigate disruptions.

\sphinxAtStartPar
The case involves a collaboration between MIT researchers and Ford Motor Company to develop a new method for assessing risks associated with disruptions in a company’s supply chain. The paper outlines the challenges faced by Ford, proposes a new model called the risk\sphinxhyphen{}exposure index (REI), and details two related models, the time\sphinxhyphen{}to\sphinxhyphen{}recover (TTR) and time\sphinxhyphen{}to\sphinxhyphen{}survive (TTS), to assess these risks.

\sphinxAtStartPar
\sphinxstylestrong{Challenges Faced by Ford}

\sphinxAtStartPar
Ford, like many companies, faces challenges in proactively managing disruptions in its supply chain caused by low\sphinxhyphen{}probability, high\sphinxhyphen{}impact events. These disruptions are difficult to predict and quantify, and can have a significant material impact on a company’s performance. The complexity and scale of Ford’s supply chain, with over 4,400 manufacturing sites across 10 tiers of suppliers, further complicate this problem.

\sphinxAtStartPar
\sphinxstylestrong{Risk Exposure Index (REI)}

\sphinxAtStartPar
The REI is a model developed to address the limitations of legacy risk\sphinxhyphen{}assessment processes. These legacy processes typically focus on tracking a small number of suppliers and parts, and may not identify significant exposures hidden among lower\sphinxhyphen{}tier suppliers. The REI defers the need to estimate the probability of specific disruptions by focusing instead on the impact of the disruption itself, regardless of the cause. In other words, REI is calculated as the relative value of the potential disruption cost faced by a location divided by the maximum disruption cost faced in the worst case scenario. This allows Ford to identify the weakest links in its supply chain and allocate resources more effectively towards mitigating those risks.

\sphinxAtStartPar
\sphinxstylestrong{Time\sphinxhyphen{}to\sphinxhyphen{}Recover (TTR) and Time\sphinxhyphen{}to\sphinxhyphen{}Survive (TTS) Models}

\sphinxAtStartPar
The TTR and TTS models are mathematical tools used in conjunction with the REI to assess the impact of disruptions on Ford’s supply chain.

\sphinxAtStartPar
** \sphinxhyphen{} The TTR model** considers the time it takes for each supplier in the supply chain to recover from a disruption. It factors in operational and financial data, along with in\sphinxhyphen{}transit and on\sphinxhyphen{}site inventory levels, to simulate the impact of a disruption on Ford’s performance metrics such as lost production or sales.{[}1{]}
** \sphinxhyphen{} The TTS model** calculates the maximum amount of time Ford’s system can function without demand loss if a particular supplier is disrupted. This allows Ford to identify suppliers who are critical to its operations and warrant further investigation into their recovery timelines.

\sphinxAtStartPar
Both the TTR and TTS models are linear programming (LP) models, which can be solved very efficiently.

\sphinxAtStartPar
\sphinxstylestrong{Reducing Disruption Risks}

\sphinxAtStartPar
By using the REI, TTR, and TTS models, Ford can gain valuable insights into the weakest links in its supply chain and the potential impact of disruptions. This allows Ford to develop targeted risk\sphinxhyphen{}mitigation strategies such as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Identifying critical suppliers and collaborating with them to improve their disaster preparedness.

\item {} 
\sphinxAtStartPar
Diversifying sources of supply to reduce reliance on any single supplier.

\item {} 
\sphinxAtStartPar
Stockpiling critical parts to mitigate the impact of disruptions.

\end{itemize}

\sphinxAtStartPar
Overall, the proposed approach allows Ford to make data\sphinxhyphen{}driven decisions to reduce its vulnerability to supply chain disruptions.

\sphinxAtStartPar
The overall workflow can be depicted as follows (Figure from Simchi\sphinxhyphen{}Levi, 2015).



\sphinxstepscope


\section{Demo: Supply Chain Distruption Risk Analytics}
\label{\detokenize{docs/Case3_1_Disruption_Risk_Analytics:demo-supply-chain-distruption-risk-analytics}}\label{\detokenize{docs/Case3_1_Disruption_Risk_Analytics::doc}}
\sphinxAtStartPar
We start our prescriptive modeling by installing the (i) Pyomo package and (ii) the linear programming solver GLPK (GNU Linear Programming Kit). Please feel free to revisit \sphinxhref{https://colab.research.google.com/github/acedesci/scanalytics/blob/master/EN/S08\_09\_Retail\_Analytics/S9\_Module2A\_Retail\_Price\_Optimization.ipynb}{Online Fulfillment Demo} for further information.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Install Pyomo and GLPK in your Python environment if it is not already done.}
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{q} \PYG{n}{pyomo}
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge}\PYG{p}{:}\PYG{p}{:}\PYG{n}{glpk}
\end{sphinxVerbatim}


\subsection{Blocks 1\&2: Data inputs and parameters}
\label{\detokenize{docs/Case3_1_Disruption_Risk_Analytics:blocks-1-2-data-inputs-and-parameters}}
\sphinxAtStartPar
We have two different datasets. The latter has more complex configurations, but their structures are similar.
\begin{itemize}
\item {} 
\sphinxAtStartPar
In problem 1, the instance consists of 3 suppliers, 2 products (vehicles) and 4 scenarios. There is only one supply chain configuration;

\item {} 
\sphinxAtStartPar
In problem 2, the instance consists of 5 suppliers, 8 products (vehicles) and 21 scenarios. There are three supply chain configurations (A, B and C) and the analysis for each configuration must be done separately (in different runs).

\end{itemize}

\sphinxAtStartPar
We would recommend that you review problem 1 to see the structure of the model prior to trying the problem 2.

\sphinxAtStartPar
** Details of data inputs \& parameters **
The DataFrame \sphinxstylestrong{inputScenarios} contains the values of active link \(\alpha_{ij}^n\) from supply node \(i\) for product/vehicle \(j\) each scenario \(n\). \(\alpha_{ij}^n = 1\) indicates that that link is active in this scenario whereas \(\alpha_{ij}^n=0\) indicates that the link is inactive (disrupted/not used) in that scenario.

\sphinxAtStartPar
Meanwhile, the DataFrame \sphinxstylestrong{inputParameters} contains a set of parameters as follows:
() contains the capacity of each supplier (in \sphinxstylestrong{supplierList}), demand for
\begin{itemize}
\item {} 
\sphinxAtStartPar
Column \sphinxstyleemphasis{Type} indicates if the parameter is for the supply node (Supplier) or product node (Product)

\item {} 
\sphinxAtStartPar
Column \sphinxstyleemphasis{Parameter} indicates what parameter is given in that row. The parameters include

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Capacity of supply node \(i\): \(c_i\)

\item {} 
\sphinxAtStartPar
Demand of product node \(j\): \(d_j\)

\item {} 
\sphinxAtStartPar
Initial inventory of product \(j\): \(s_j\)

\item {} 
\sphinxAtStartPar
Unit profit (profit margin) of product \(j\): \(f_j\)

\item {} 
\sphinxAtStartPar
Time\sphinxhyphen{}to\sphinxhyphen{}recover (TTR) of each scenario \(n\): \(t^n\)

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Column \sphinxstyleemphasis{Index} indicates the index associated with that parameter

\item {} 
\sphinxAtStartPar
Column \sphinxstyleemphasis{Value} indicates the value of that parameter

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{pyomo}\PYG{n+nn}{.}\PYG{n+nn}{environ} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display} \PYG{c+c1}{\PYGZsh{} this one can be used to display dataframes in case you want to print out multiple of them}

\PYG{c+c1}{\PYGZsh{} Problem 1 (small scale, one configuration)}
\PYG{n}{urlParameters} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S11\PYGZus{}Disruption\PYGZus{}Management/inputParameters\PYGZus{}Prob1.csv}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{urlScenario}  \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S11\PYGZus{}Disruption\PYGZus{}Management/inputScenarios\PYGZus{}Prob1.csv}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Problem 2 (large scale, 3 possible SC configurations \PYGZhy{} A, B and C)}
\PYG{c+c1}{\PYGZsh{} urlParameters = \PYGZsq{}https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S11\PYGZus{}Disruption\PYGZus{}Management/inputParameters\PYGZus{}Prob2.csv\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Here are the scenarios under each configuration. The analysis could be done for one SC configuration at a time so only choose one url among them.}
\PYG{c+c1}{\PYGZsh{} urlScenario  = \PYGZsq{}https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S11\PYGZus{}Disruption\PYGZus{}Management/inputScenarios\PYGZus{}Prob2\PYGZus{}Config\PYGZus{}A.csv\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} urlScenario  = \PYGZsq{}https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S11\PYGZus{}Disruption\PYGZus{}Management/inputScenarios\PYGZus{}Prob2\PYGZus{}Config\PYGZus{}B.csv\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{} urlScenario  = \PYGZsq{}https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S11\PYGZus{}Disruption\PYGZus{}Management/inputScenarios\PYGZus{}Prob2\PYGZus{}Config\PYGZus{}C.csv\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} read CSV files}
\PYG{n}{inputScenarios} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{urlScenario}\PYG{p}{)}
\PYG{n}{inputParameters} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{urlParameters}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Just in case you want to see the loaded DataFrames, you can display or print them}
\PYG{c+c1}{\PYGZsh{} (display gives a more beautiful output for DataFrame)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{inputScenarios}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
  Node Product  Scenario\PYGZus{}0  Scenario\PYGZus{}1  Scenario\PYGZus{}2  Scenario\PYGZus{}3
0   S1      P1           1           0           1           1
1   S1      P2           1           0           1           1
2   S2      P1           1           1           0           1
3   S2      P2           1           1           0           1
4   S3      P1           1           1           1           0
5   S3      P2           1           1           1           0
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          Type  Parameter       Index  Value
0     Supplier   Capacity          S1     30
1     Supplier   Capacity          S2     45
2     Supplier   Capacity          S3     60
3      Product     Demand          P1     75
4      Product     Demand          P2     50
5      Product  Inventory          P1     20
6      Product  Inventory          P2     25
7      Product       Loss          P1   5000
8      Product       Loss          P2   6500
9   Disruption        TTR  Scenario\PYGZus{}0      2
10  Disruption        TTR  Scenario\PYGZus{}1      2
11  Disruption        TTR  Scenario\PYGZus{}2      2
12  Disruption        TTR  Scenario\PYGZus{}3      2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We then create the inputs used in the Pyomo model from the DataFrames above.

\sphinxAtStartPar
\sphinxstylestrong{Lists}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{productList} contains the list of products (vehicles), or set \(\mathcal{V}\)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{supplierList} contains the list of supply nodes (plants), or set \(\mathcal{A}\)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{scenarioList} contains the list of scenarios

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Dictionaries of data}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{supplierCapacityDict{[}i{]}} contains the values of \(c_i\);

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{productDemandDict{[}j{]}} contains the values of \(d_j\);

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{productInvDict{[}j{]}} contains the values of \(s_j\);

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{productLossDict{[}j{]}} contains the values of \(f_j\);

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{scenarioTTRDict{[}n{]}} contains the values of \(t^n\);

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{scenarioActiveNodeDict{[}n{]}{[}(i,j){]}} contains the values of \(\alpha^n_{ij}\) whether the link \((i,j)\) is active in scenario \(n\) for not.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{productList} \PYG{o}{=} \PYG{n}{inputParameters}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Product}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{supplierList} \PYG{o}{=} \PYG{n}{inputParameters}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Supplier}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{scenarioList} \PYG{o}{=} \PYG{n}{inputParameters}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Disruption}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{supplierCapacityDict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{supplierList}\PYG{p}{:}
  \PYG{n}{cap} \PYG{o}{=} \PYG{n}{inputParameters}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Parameter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Capacity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
  \PYG{n}{supplierCapacityDict}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{cap}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Print SupplierCapacityDict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{supplierCapacityDict}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{supplierCapacityDict}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(\PYGZsq{}\PYGZbs{}n\PYGZsq{})}

\PYG{n}{productDemandDict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{productInvDict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{productLossDict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
  \PYG{n}{dem} \PYG{o}{=} \PYG{n}{inputParameters}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Parameter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
  \PYG{n}{inv} \PYG{o}{=} \PYG{n}{inputParameters}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Parameter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Inventory}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
  \PYG{n}{loss} \PYG{o}{=} \PYG{n}{inputParameters}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Parameter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Loss}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
  \PYG{n}{productDemandDict}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{dem}
  \PYG{n}{productInvDict}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{inv}
  \PYG{n}{productLossDict}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{loss}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Print productDemandDict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{productDemandDict}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{productDemandDict}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(\PYGZsq{}\PYGZbs{}n\PYGZsq{})}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Print productInvDict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{productInvDict}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{productInvDict}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(\PYGZsq{}\PYGZbs{}n\PYGZsq{})}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Print productLossDict}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{productLossDict}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{productLossDict}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(\PYGZsq{}\PYGZbs{}n\PYGZsq{})}

\PYG{n}{scenarioTTRDict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{scenarioActiveNodeDict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{scenarioList}\PYG{p}{:}
  \PYG{n}{ttr} \PYG{o}{=} \PYG{n}{inputParameters}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Parameter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TTR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{inputParameters}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{n}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
  \PYG{n}{scenarioTTRDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ttr}
  \PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{nActiveLinks} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{inputScenarios}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{: N. active links = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{nActiveLinks}\PYG{p}{)}

  \PYG{k}{for} \PYG{n}{ind} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{index}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{supp} \PYG{o}{=} \PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Node}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{prod} \PYG{o}{=} \PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Product}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{supp}\PYG{p}{,}\PYG{n}{prod}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{inputScenarios}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Print SupplierCapacityDict
S1  :  30
S2  :  45
S3  :  60
Print productDemandDict
P1  :  75
P2  :  50
Print productInvDict
P1  :  20
P2  :  25
Print productLossDict
P1  :  5000
P2  :  6500
Scenario\PYGZus{}0: N. active links =  6
Scenario\PYGZus{}1: N. active links =  4
Scenario\PYGZus{}2: N. active links =  4
Scenario\PYGZus{}3: N. active links =  4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Blocks 3 \& 4: Optimization model \& results}
\label{\detokenize{docs/Case3_1_Disruption_Risk_Analytics:blocks-3-4-optimization-model-results}}
\sphinxAtStartPar
Since the risk exposure analytics framework requires solving one linear programming (LP) for each scenario at a time, we make use of the \sphinxstyleemphasis{for} loop to perform the procedure which create an LP which is loaded with the parameters for each scenario \(n\) and solve the model iteratively to obtain the optimal solution corresponding to that scenario.  There are two optimizatiom models, i.e., TTR and TTS models.


\bigskip\hrule\bigskip



\subsubsection{Block 3A: \sphinxstylestrong{TTR Model:}}
\label{\detokenize{docs/Case3_1_Disruption_Risk_Analytics:block-3a-ttr-model}}
\sphinxAtStartPar
The first model is the best\sphinxhyphen{}response model based on the TTR. The components of the models are as follows. Note that these variables are created for each scenario but the scenario index \(n\) is dropped:

\sphinxAtStartPar
(i) \sphinxstylestrong{Decision variables:} consists of the following variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
model.\sphinxstylestrong{l}\([j]\) (or \(l_{j}\)): the number of unit loss of product \sphinxstyleemphasis{j} at supplier \sphinxstyleemphasis{i};

\item {} 
\sphinxAtStartPar
model.\sphinxstylestrong{y}\([i, j]\) (or \(y_{ij}\)) the amount of product \sphinxstyleemphasis{j} produced at supplier \sphinxstyleemphasis{i};

\end{itemize}

\sphinxAtStartPar
(ii) \sphinxstylestrong{Objective function:} In the TTR model, we want to minimize the total profit loss due to disruption in each scenario, i.e.,
\begin{equation*}
\begin{split}\min_{y,l} \sum_{j\in \mathcal{V}} f_j \cdot l_j\end{split}
\end{equation*}
\sphinxAtStartPar
(iii) \sphinxstylestrong{Constraints:}

\sphinxAtStartPar
\sphinxstylestrong{Constraint set 1:}  demand loss for product \(j\) **

\sphinxAtStartPar
This set of constraints helps determine the lower bound on the demand lost (\(l_j\)) during the disruption time (\(t^{n}\)) given the current inventory level (\(s_j\)) and the production amount for product \(j\) from supplier \(i\) (\(y_{ij}\)) from the active link \(\alpha^{n}_{ij}=1\).
\$\(\sum_{i\in\mathcal{A}} \left( \alpha^{n}_{ij} \cdot y_{ij} \right) + l_j \geq d_j \cdot t^{n} - s_j,\quad \forall j\in \mathcal{V} \)\$

\sphinxAtStartPar
\sphinxstylestrong{Constraint set 2:}  capacity at each supplier \(i\)

\sphinxAtStartPar
This set of constraints ensures that the cumulative production output of supplier \(i\) is within the capacity of that supplier if it is still active \(\left(\alpha^{n}_{ij}=1\right)\). Note that we need to check if at least one link \(\alpha^{n}_{ij}\) for supplier \(i\) is active for that scenario, otherwise Pyomo will return an error. In the case when there is no active link, we will omit that supplier in the model (since that supplier will not be used anyway). This is done in the codes when we use the boolean \sphinxstyleemphasis{noSupply}.
\begin{equation*}
\begin{split}\sum_{j\in\mathcal{V}} \alpha^{n}_{ij} \cdot y_{ij}  \leq c_i \cdot t^{(n)},\quad \forall i\in \mathcal{A} \end{split}
\end{equation*}

\subsubsection{Block 4: Solution and results}
\label{\detokenize{docs/Case3_1_Disruption_Risk_Analytics:block-4-solution-and-results}}
\sphinxAtStartPar
To aggregate the results from each scenario, we calculate and store the results in the \sphinxstylestrong{scenarioResults} DataFrame which stores the following results based on the optimal solution \(\left( \mathbf{l}^{n,*}, \mathbf{y}^{n,*} \right)\) for each scenario \(n\) : ‘disruptionCost’ \(\left( \sum_j f_j \cdot l_j^{n,*} \right)\), ‘riskExposureIndex’ \(\left( \frac{C^n}{C^{\max}} \right)\), ‘lostUnits’ \(\left( \sum_j l_j^{n,*} \right)\), ‘totalProduction’ \(\left( \sum_i \sum_j y_{ij}^{n,*} \right)\), ‘activeLinks’ (how many links are active under a given scenario)\$, and ‘utilizedLinks’ (how many links are used in the solution of a given scenario).

\sphinxAtStartPar
Finally, we display the descriptive statistics of the results over all disruption scenarios. Here we make use of function \sphinxstyleemphasis{discribe()} in pandas \sphinxhref{https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.describe.html}{(Link)} and \sphinxstyleemphasis{hist()} in matplotlib \sphinxhref{https://matplotlib.org/3.2.1/api/\_as\_gen/matplotlib.pyplot.hist.html}{(Link)}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} TTR Model}

\PYG{n}{disruptionCost} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{disruptionResponse} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{disruptionDemandLoss} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{n}{resultcolumns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disruptionCost}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{riskExposureIndex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lostUnits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{totalProduction}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{activeLinks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utilizedLinks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{TTRscenarioResults} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{columns} \PYG{o}{=} \PYG{n}{resultcolumns}\PYG{p}{,} \PYG{n}{index} \PYG{o}{=} \PYG{n}{scenarioList}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{scenarioList}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}Analyzing:\PYGZdq{}+str(n))}
  \PYG{n}{model} \PYG{o}{=} \PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Variables}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{l} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{n}{productList}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{NonNegativeReals}\PYG{p}{)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{n}{supplierList}\PYG{p}{,} \PYG{n}{productList}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{NonNegativeReals}\PYG{p}{)}

  \PYG{n}{model}\PYG{o}{.}\PYG{n}{demandLoss} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{supplierCapacity} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Objective function}
  \PYG{n}{obj\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{productLossDict}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{l}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{)}
  \PYG{c+c1}{\PYGZsh{} print(obj\PYGZus{}expr)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{OBJ} \PYG{o}{=} \PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{obj\PYGZus{}expr}\PYG{p}{,} \PYG{n}{sense} \PYG{o}{=} \PYG{n}{minimize}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Constraints 1 calculate demand loss for each product}
  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
    \PYG{n}{const\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{supplierList}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
                  \PYG{n}{model}\PYG{o}{.}\PYG{n}{l}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{productDemandDict}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{scenarioTTRDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{productInvDict}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} print(const\PYGZus{}expr)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{demandLoss}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const\PYGZus{}expr}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Constraints 2 capacity at each supplier i}
  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{supplierList}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} check if there is any left hand side (i.e., if there is at least one available active link), otherwise pyomo will return an error}
    \PYG{n}{noSupply} \PYG{o}{=} \PYG{k+kc}{True}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
      \PYG{k}{if} \PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{noSupply} \PYG{o}{=} \PYG{k+kc}{False}
        \PYG{k}{break}

    \PYG{c+c1}{\PYGZsh{} we generate the constraint only if noSupply = False}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{noSupply}\PYG{p}{:}
      \PYG{n}{const\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{supplierCapacityDict}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{scenarioTTRDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}
      \PYG{c+c1}{\PYGZsh{}print(const\PYGZus{}expr)}
      \PYG{n}{model}\PYG{o}{.}\PYG{n}{supplierCapacity}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const\PYGZus{}expr}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Solve the model}
  \PYG{n}{opt} \PYG{o}{=} \PYG{n}{SolverFactory}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{glpk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Save the result for each scenario}

  \PYG{n}{disruptionCost}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{OBJ}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{TTRscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disruptionCost}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{disruptionCost}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}

  \PYG{n}{disruptionResponse}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{nUtilizedLinks} \PYG{o}{=} \PYG{l+m+mi}{0}
  \PYG{k}{for} \PYG{n}{ind} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{index}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{i} \PYG{o}{=} \PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Node}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{j} \PYG{o}{=} \PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Product}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

      \PYG{k}{if} \PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{disruptionResponse}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}
        \PYG{k}{if} \PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.1}\PYG{p}{:}
          \PYG{n}{nUtilizedLinks} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
      \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{disruptionResponse}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

  \PYG{n}{TTRscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{totalProduction}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{disruptionResponse}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{TTRscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{activeLinks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{TTRscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utilizedLinks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{nUtilizedLinks}

  \PYG{n}{disruptionDemandLoss}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
    \PYG{n}{disruptionDemandLoss}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{l}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}

  \PYG{n}{TTRscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lostUnits}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{disruptionDemandLoss}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{TTRscenarioResults}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disruptionCost}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.001}\PYG{p}{:}
  \PYG{n}{TTRscenarioResults}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{riskExposureIndex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{TTRscenarioResults}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disruptionCost}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{TTRscenarioResults}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disruptionCost}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:} \PYG{n}{TTRscenarioResults}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{riskExposureIndex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.0}

\PYG{c+c1}{\PYGZsh{} Show the results}
\PYG{n}{pandas}\PYG{o}{.}\PYG{n}{options}\PYG{o}{.}\PYG{n}{display}\PYG{o}{.}\PYG{n}{float\PYGZus{}format} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:,.3f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{TTRscenarioResults}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
           disruptionCost riskExposureIndex lostUnits totalProduction  \PYGZbs{}
Scenario\PYGZus{}0          0.000             0.000     0.000         205.000   
Scenario\PYGZus{}1          0.000             0.000     0.000         205.000   
Scenario\PYGZus{}2    125,000.000             0.455    25.000         180.000   
Scenario\PYGZus{}3    275,000.000             1.000    55.000         150.000   

           activeLinks utilizedLinks  
Scenario\PYGZus{}0           6             4  
Scenario\PYGZus{}1           4             3  
Scenario\PYGZus{}2           4             3  
Scenario\PYGZus{}3           4             3  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Here we make use of the function hist() to plot the histogram based on the analyzed scenarios}
\PYG{n}{TTRscenarioResults}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disruptionCost}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{801d037b1982b7385583992b7e727a044723e2d117408b4b6820f996b8c9f601}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Block 3B: \sphinxstylestrong{TTS Model:}}
\label{\detokenize{docs/Case3_1_Disruption_Risk_Analytics:block-3b-tts-model}}
\sphinxAtStartPar
The second model is the time\sphinxhyphen{}to\sphinxhyphen{}survive (TTS) model to determine how long the disrupted supply chain can last until the demand is lost. The components of the models are as follows.

\sphinxAtStartPar
(i) \sphinxstylestrong{Decision variables:} consist of:
\begin{itemize}
\item {} 
\sphinxAtStartPar
model.\sphinxstylestrong{t}\([n]\) (or \(t^{n}\)): time\sphinxhyphen{}to\sphinxhyphen{}survive (TTS) for scenario \(n\)

\item {} 
\sphinxAtStartPar
model.\sphinxstylestrong{y}\([i, j]\) (or \(y_{ij}\)) the amount of product \sphinxstyleemphasis{j} produced at supplier \sphinxstyleemphasis{i};

\end{itemize}

\sphinxAtStartPar
(ii) \sphinxstylestrong{Objective function:} In the TTS model, we want to maximize the TTS in each scenario, i.e.,
\begin{equation*}
\begin{split}\max_{y,t} t^n\end{split}
\end{equation*}
\sphinxAtStartPar
(iii) \sphinxstylestrong{Constraints:}

\sphinxAtStartPar
\sphinxstylestrong{Constraint set 1:}  demand of product \(j\) must be satisfied without loss**

\sphinxAtStartPar
This set of constraints helps determine how long the demand can be fully satisfied without loss (\(t^{n}\)) given the current inventory level (\(s_j\)) and the production amount for product \(j\) from supplier \(i\) (\(y_{ij}\)) if the  link is active \(\alpha^{n}_{ij}=1\).
\$\(\sum_{i\in\mathcal{A}} \alpha^{n}_{ij} \cdot y_{ij} \geq d_j \cdot t^{n} - s_j,\quad \forall j\in \mathcal{V} \)\$

\sphinxAtStartPar
\sphinxstylestrong{Constraint set 2:}  capacity at each supplier \(i\)

\sphinxAtStartPar
This set of constraints ensures that the cumulative production output of supplier \(i\) is within the capacity of that supplier if it is still active \(\left(\alpha^{n}_{ij}=1\right)\). Note that we need to check if at least one link \(\alpha^{n}_{ij}\) for supplier \(i\) is active for that scenario, otherwise Pyomo will return an error. In the case when there is no active link, we will omit that supplier in the model (since that supplier will not be used anyway). This is done in the codes when we use the boolean \sphinxstyleemphasis{noSupply}.
\begin{equation*}
\begin{split}\sum_{j\in\mathcal{V}} \alpha^{n}_{ij} \cdot y_{ij}   \leq c_i \cdot t^{(n)},\quad \forall i\in \mathcal{A} \end{split}
\end{equation*}

\subsubsection{Block 4: Solution and results}
\label{\detokenize{docs/Case3_1_Disruption_Risk_Analytics:id1}}
\sphinxAtStartPar
To aggregate the results from each scenario, we calculate and store the results in the \sphinxstylestrong{scenarioResults} DataFrame which stores the following results based on the optimal solution \(\left( t^{n,*}, \mathbf{y}^{n,*} \right)\) for each scenario \(n\) : ‘TTS’ \((t^n)\), ‘totalProduction’ \(\left( \sum_i \sum_j y_{ij}^{n,*} \right)\), ‘activeLinks’ (how many links are active under a given scenario)\$, and ‘utilizedLinks’ (how many links are used in the solution of a given scenario).

\sphinxAtStartPar
Finally, we display the descriptive statistics of the results over all disruption scenarios. Here we make use of function \sphinxstyleemphasis{discribe()} in pandas \sphinxhref{https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.describe.html}{(Link)} and \sphinxstyleemphasis{hist()} in matplotlib \sphinxhref{https://matplotlib.org/3.2.1/api/\_as\_gen/matplotlib.pyplot.hist.html}{(Link)}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} TTS Model}

\PYG{n}{timeToSurvive} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{disruptionResponse} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{disruptionDemandLoss} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

\PYG{n}{resultcolumns} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TTS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TTR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nShortagePeriods}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{activeLinks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utilizedLinks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{TTSscenarioResults} \PYG{o}{=} \PYG{n}{pandas}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{columns} \PYG{o}{=} \PYG{n}{resultcolumns}\PYG{p}{,} \PYG{n}{index} \PYG{o}{=} \PYG{n}{scenarioList}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{scenarioList}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}Analyzing:\PYGZdq{}+str(n))}
  \PYG{n}{model} \PYG{o}{=} \PYG{n}{ConcreteModel}\PYG{p}{(}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Variables}
  \PYG{c+c1}{\PYGZsh{} There is only one variable t so we give a list of one value.}
  \PYG{c+c1}{\PYGZsh{} If the SC is robust for that scenario, the variable t will be equal to infinity}
  \PYG{c+c1}{\PYGZsh{} so we limit the max to a sufficiently large number (999 periods in this case)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{t} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{NonNegativeReals}\PYG{p}{,} \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{999}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{Var}\PYG{p}{(}\PYG{n}{supplierList}\PYG{p}{,} \PYG{n}{productList}\PYG{p}{,} \PYG{n}{within} \PYG{o}{=} \PYG{n}{NonNegativeReals}\PYG{p}{)}

  \PYG{n}{model}\PYG{o}{.}\PYG{n}{demandSatisfaction} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{supplierCapacity} \PYG{o}{=} \PYG{n}{ConstraintList}\PYG{p}{(}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Objective function}
  \PYG{n}{obj\PYGZus{}expr} \PYG{o}{=}\PYG{n}{model}\PYG{o}{.}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
  \PYG{c+c1}{\PYGZsh{} print(obj\PYGZus{}expr)}
  \PYG{n}{model}\PYG{o}{.}\PYG{n}{OBJ} \PYG{o}{=} \PYG{n}{Objective}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{obj\PYGZus{}expr}\PYG{p}{,} \PYG{n}{sense} \PYG{o}{=} \PYG{n}{maximize}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Constraints 1 demand must be fully satisfied}
  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
    \PYG{n}{const\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{supplierList}\PYG{p}{)} \PYGZbs{}
                  \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{productDemandDict}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{productInvDict}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} print(const\PYGZus{}expr)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{demandSatisfaction}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const\PYGZus{}expr}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Constraints 2 capacity at each supplier i}
  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{supplierList}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} check if there is any left hand side (i.e., if there is at least one available active link), otherwise pyomo will return an error}
    \PYG{n}{noSupply} \PYG{o}{=} \PYG{k+kc}{True}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{:}
      \PYG{k}{if} \PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{noSupply} \PYG{o}{=} \PYG{k+kc}{False}
        \PYG{k}{break}

    \PYG{c+c1}{\PYGZsh{} we generate the constraint only if noSupply = False}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{noSupply}\PYG{p}{:}
      \PYG{n}{const\PYGZus{}expr} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{productList}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{supplierCapacityDict}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{model}\PYG{o}{.}\PYG{n}{t}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
      \PYG{c+c1}{\PYGZsh{}print(const\PYGZus{}expr)}
      \PYG{n}{model}\PYG{o}{.}\PYG{n}{supplierCapacity}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{expr} \PYG{o}{=} \PYG{n}{const\PYGZus{}expr}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Solve the model}
  \PYG{n}{opt} \PYG{o}{=} \PYG{n}{SolverFactory}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{glpk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
  \PYG{n}{opt}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}

  \PYG{c+c1}{\PYGZsh{} Save the result for each scenario}

  \PYG{n}{timeToSurvive}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{OBJ}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{TTSscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TTS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{timeToSurvive}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
  \PYG{n}{TTSscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TTR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{scenarioTTRDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}

  \PYG{n}{disruptionResponse}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
  \PYG{n}{nUtilizedLinks} \PYG{o}{=} \PYG{l+m+mi}{0}
  \PYG{k}{for} \PYG{n}{ind} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{index}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{i} \PYG{o}{=} \PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Node}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
      \PYG{n}{j} \PYG{o}{=} \PYG{n}{inputScenarios}\PYG{o}{.}\PYG{n}{iloc}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Product}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

      \PYG{k}{if} \PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{disruptionResponse}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value}
        \PYG{k}{if} \PYG{n}{model}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{value} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.1}\PYG{p}{:}
          \PYG{n}{nUtilizedLinks} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
      \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{disruptionResponse}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

  \PYG{n}{TTSscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nShortagePeriods}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{TTSscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TTR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{TTSscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TTS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{n}{TTSscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{activeLinks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{scenarioActiveNodeDict}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{.}\PYG{n}{values}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{TTSscenarioResults}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utilizedLinks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{nUtilizedLinks}

\PYG{c+c1}{\PYGZsh{} Show the results}
\PYG{n}{pandas}\PYG{o}{.}\PYG{n}{options}\PYG{o}{.}\PYG{n}{display}\PYG{o}{.}\PYG{n}{float\PYGZus{}format} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:,.3f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{TTSscenarioResults}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               TTS TTR nShortagePeriods activeLinks utilizedLinks
Scenario\PYGZus{}0 999.000   2                0           6             4
Scenario\PYGZus{}1   2.250   2                0           4             3
Scenario\PYGZus{}2   1.286   2            0.714           4             3
Scenario\PYGZus{}3   0.900   2            1.100           4             3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Intepret and show the results}
\PYG{c+c1}{\PYGZsh{} Here we make use of the function hist() to plot the histogram}
\PYG{n}{TTSscenarioResults}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nShortagePeriods}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{TTSscenarioResults}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2deaad82b442c6892c041c5c179137ad69bd5a8f7965b008dfb93cd32b1dee47}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
               TTS TTR nShortagePeriods activeLinks utilizedLinks
Scenario\PYGZus{}0 999.000   2                0           6             4
Scenario\PYGZus{}1   2.250   2                0           4             3
Scenario\PYGZus{}2   1.286   2            0.714           4             3
Scenario\PYGZus{}3   0.900   2            1.100           4             3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Additional Examples of Analytics Techniques in Supply Chains}

\sphinxstepscope


\chapter{(R, s, S) Inventory Simulation}
\label{\detokenize{docs/Ex_Lecture_Demo_Inventory_Sim:r-s-s-inventory-simulation}}\label{\detokenize{docs/Ex_Lecture_Demo_Inventory_Sim::doc}}
\sphinxAtStartPar
The (R, s, S) inventory policy is a type of periodic review inventory control system. It involves three key decision variables:

\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{} Review Period (R):} The time interval between inventory checks.
\sphinxstylestrong{\sphinxhyphen{} Reorder Point (s):} The level of inventory at which a replenishment order is placed.
\sphinxstylestrong{\sphinxhyphen{} Target level (S):} The target level of inventory position to be reached when an order is placed.

\sphinxAtStartPar
How it Works:

\sphinxAtStartPar
Inventory Review: Inventory levels are checked at regular intervals (R).
Order Placement: If the inventory level is below or equal to the reorder point (s), an order is placed until the inventory position (current inventory plus incoming order) reaches the level S.
Replenishment: The ordered items are received and added to inventory.

\sphinxAtStartPar
The (R, s, S) policy is widely adopted due to its simplicity, practicality, and effectiveness as it is easy to understand and implement. It can be adapted to various inventory situations and reduces the need for constant inventory monitoring.

\sphinxAtStartPar
Optimizing an (R, s, S) inventory policy, a common inventory control method, can be challenging due to several factors:

\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{} Uncertainty:} Demand is often uncertain, making it difficult to predict future needs accurately. This uncertainty can lead to stockouts or excess inventory.
Interdependencies: Inventory decisions are often interconnected with other operational factors, such as production capacity, transportation costs, and customer service levels. Optimizing one factor may negatively impact another.
\sphinxstylestrong{\sphinxhyphen{} Complexity:} The (R, s, S) policy involves three decision variables: review period (R), reorder point (s), and target level (S). Finding the optimal combination of these variables can be computationally intensive.
\sphinxstylestrong{\sphinxhyphen{} Multiple Objectives:} Inventory management often involves competing objectives, such as minimizing costs, maximizing service levels, and reducing stockouts. Balancing these objectives can be challenging.

\sphinxAtStartPar
Thus, simulation can be a valuable tool for addressing these challenges:

\sphinxAtStartPar
\sphinxstylestrong{\sphinxhyphen{} Modeling Uncertainty:} Simulation can model demand uncertainty using probability distributions, allowing for a better understanding of potential outcomes.
\sphinxstylestrong{\sphinxhyphen{} Testing Different Scenarios:} By running multiple simulations with different parameter values, decision\sphinxhyphen{}makers can evaluate the impact of various (R, s, S) policies on performance metrics like costs, service levels, and stockouts.
\sphinxstylestrong{\sphinxhyphen{} Identifying Trade\sphinxhyphen{}offs:} Simulation can help identify trade\sphinxhyphen{}offs between different objectives, allowing decision\sphinxhyphen{}makers to make informed choices.
\sphinxstylestrong{\sphinxhyphen{} Optimization:} Simulation can be integrated with optimization algorithms to find near\sphinxhyphen{}optimal (R, s, S) policies.

\sphinxAtStartPar
In summary, simulation offers a flexible and powerful approach to optimizing (R, s, S) inventory policies by providing insights into uncertain demand, evaluating the impact of different policies, and helping to balance competing objectives.


\bigskip\hrule\bigskip


\sphinxAtStartPar
This notebook provides an example of the use of \sphinxcode{\sphinxupquote{DataFrame}} to calculate the inventory performance based on estimated demand. The objective for you to review this is to \sphinxstyleemphasis{understand} what each block of codes does. Developing it by yourself requires time and experience but if you generally understand the process and codes, that would suffice.


\bigskip\hrule\bigskip



\chapter{Inventory simulation using pandas}
\label{\detokenize{docs/Ex_Lecture_Demo_Inventory_Sim:inventory-simulation-using-pandas}}
\sphinxAtStartPar
In this exercise, you will use pandas library to simulate different inventory policies for a planning horizon of one year.


\section{Step 1: Reading data}
\label{\detokenize{docs/Ex_Lecture_Demo_Inventory_Sim:step-1-reading-data}}
\sphinxAtStartPar
Import the pandas library under the alias \sphinxcode{\sphinxupquote{pd}}. Import the csv file \sphinxcode{\sphinxupquote{DemandSimulation.csv}} into a \sphinxcode{\sphinxupquote{DataFrame}}, and select the first column named \sphinxcode{\sphinxupquote{'Week'}} as the index of the \sphinxcode{\sphinxupquote{DataFrame}}.

\sphinxAtStartPar
\sphinxstylestrong{\(\color{blue}{\textbf{Hint:}}\)} you can define the index column of the \sphinxcode{\sphinxupquote{DataFrame}} using the \sphinxcode{\sphinxupquote{index\_col}} parameter of the \sphinxcode{\sphinxupquote{.read\_csv()}} function. Check \sphinxhref{https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read\_csv.html}{this page} for more information.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}

\PYG{c+c1}{\PYGZsh{} There is a csv file which I put in online. You can also download but we will load directly from the link.}
\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S04\PYGZus{}Data\PYGZus{}Structures\PYGZus{}2/DemandScenarios.csv}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{demand\PYGZus{}scenario\PYGZus{}df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{url}\PYG{p}{,} \PYG{n}{index\PYGZus{}col}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Week}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now display the first 10 rows of your \sphinxcode{\sphinxupquote{DataFrame}}. You can see that the file contains first column as indexes (weeks) and each of the subsequent column contains a list of estimated demands for each scenario.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{demand\PYGZus{}scenario\PYGZus{}df}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      Scenario1  Scenario2  Scenario3
Week                                 
1            18         21         17
2            16         16         15
3            13         13         11
4            17         17         16
5            11         11         10
6            20         23         18
7            15         17         13
8            20         20         17
9            15         16         13
10           10         10          9
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip



\section{Step 2: Simulation and output a \sphinxstyleliteralintitle{\sphinxupquote{DataFrame}} object}
\label{\detokenize{docs/Ex_Lecture_Demo_Inventory_Sim:step-2-simulation-and-output-a-dataframe-object}}
\sphinxAtStartPar
Now, we will simulate different inventory policies based on the inventory model \((s,S)\) for a specific demand scenario and analyze/visualize the performance based on a given policy based on that specific demand scenario.
\begin{quote}

\sphinxAtStartPar
The inventory model min\sphinxhyphen{}max or \((s,S)\) is one of the most commonly used inventory system in practice. Here are the details of the inventory system. In this one, the min/max is applied to periodic system where the inventory is checked periodically every period (e.g., once a day or once a week) (Note that this sytem can also be applied in a real\sphinxhyphen{}time ordering system but in practice orders would be placed periodically).
\begin{itemize}
\item {} 
\sphinxAtStartPar
There are two parameters that must be determined to control the inventory replenishment: \(s\) which represents the minimum inventory level (or reorder point), and \(S\) which represents the desired target inventory level.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{At the beginning of each period}, this system constantly checks the inventory position (current inventory + in\sphinxhyphen{}transit inventory) for the product.

\item {} 
\sphinxAtStartPar
If the inventory position drops below the min level \(s\), the systems create an order refill inventory to raise the inventory position to the max level \(S\). The order quantity Q is then Q = S \sphinxhyphen{} inventory\_position (recall that inventory position = current + in\sphinxhyphen{}transit). This order quantity arrives after the lead time.

\end{itemize}
\end{quote}

\sphinxAtStartPar
In this exercise you will create a function which simulates your inventory performance for a given \((s,S)\) policy. This function should return a \sphinxcode{\sphinxupquote{DataFrame}} object containing inventory levels (at the begining and at the end of each period), orders to place and order to receive at each time period (week) of the simulated planning horizon. Here there are some instructions.

\sphinxAtStartPar
The function will require the following input parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Series}} from of one scenario from the DataFrame, which contains the simulated demand data for that specific scenario

\item {} 
\sphinxAtStartPar
(number) initial inventory level at the begining of the planning horizon

\item {} 
\sphinxAtStartPar
(number) lead time in weeks

\item {} 
\sphinxAtStartPar
(number) \(s\) value, i.e., minimum inventory level

\item {} 
\sphinxAtStartPar
(number) \(S\) value, i.e., maximun inventory level

\end{itemize}

\sphinxAtStartPar
The output of your function should be a \sphinxcode{\sphinxupquote{DataFrame}} with 52 rows (52 weeks) and  four columns as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{'Start\_Inv'}}: inventory level at the beginning of each week

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{'Receipt'}}: units receipt at each week

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{'Ending\_Inv'}}: inventory level at the end of each week

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{'Order'}}: order quantity in units

\end{itemize}

\sphinxAtStartPar
Note that the inventory level can be negative if you have a backlog (demand is more than available quantity). In that case, the negative value is carried forward to a subsequent period to be satistied.

\sphinxAtStartPar
\sphinxstylestrong{\(\color{blue}{\textbf{Hints:}}\)}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We use the method \sphinxcode{\sphinxupquote{df.index}} to access the list of indexes of the \sphinxcode{\sphinxupquote{DataFrame}} you created in the previous exercises.}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We initialize the first row of the \sphinxcode{\sphinxupquote{'Start\_Inv'}} column as the initial inventory level given as input. You can also initialize the \sphinxcode{\sphinxupquote{'Receipt'}} entries as \(0\) from the beginning of the planning horizon until the time period equals to the lead time.}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We then use a \sphinxcode{\sphinxupquote{for}} loop to iterate over the planning horizon and compute the corresponding values for \sphinxcode{\sphinxupquote{'Start\_Inv'}}, \sphinxcode{\sphinxupquote{'Receipt'}}, \sphinxcode{\sphinxupquote{'Ending\_Inv'}}, \sphinxcode{\sphinxupquote{'Order'}}.}

\end{itemize}

\sphinxAtStartPar
Here we provide the remaining inputs required for the simulation

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Parameters for the model}
\PYG{n}{init\PYGZus{}inv} \PYG{o}{=} \PYG{l+m+mi}{27}  \PYG{c+c1}{\PYGZsh{} initial inventory level}
\PYG{n}{lead\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{2}  \PYG{c+c1}{\PYGZsh{} leadtime}

\PYG{c+c1}{\PYGZsh{} Parameters to set (s,S) policy}
\PYG{n}{s\PYGZus{}min} \PYG{o}{=}  \PYG{l+m+mi}{25} \PYG{c+c1}{\PYGZsh{} this is the small s}
\PYG{n}{s\PYGZus{}max} \PYG{o}{=}  \PYG{l+m+mi}{70} \PYG{c+c1}{\PYGZsh{} this is the big s}

\PYG{n}{demand\PYGZus{}series} \PYG{o}{=} \PYG{n}{demand\PYGZus{}scenario\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scenario1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} we are taking the first scenario here}
\PYG{n}{demand\PYGZus{}series}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Week
1    18
2    16
3    13
4    17
5    11
Name: Scenario1, dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We can create an empty DataFrame to store the results

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} creating an (empty) dataframe to keep the results}
\PYG{n}{column\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Start\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Receipt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Order}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{n\PYGZus{}weeks} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{demand\PYGZus{}series}\PYG{o}{.}\PYG{n}{index}\PYG{p}{)}
\PYG{n}{inv\PYGZus{}dataframe} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{index} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n\PYGZus{}weeks}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{columns}\PYG{o}{=}\PYG{n}{column\PYGZus{}names}\PYG{p}{)}
\PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{index}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Week}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} give the index name to the output dataframe}
\PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     Start\PYGZus{}Inv Receipt Demand Ending\PYGZus{}Inv Order
Week                                          
1          NaN     NaN    NaN        NaN   NaN
2          NaN     NaN    NaN        NaN   NaN
3          NaN     NaN    NaN        NaN   NaN
4          NaN     NaN    NaN        NaN   NaN
5          NaN     NaN    NaN        NaN   NaN
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
You can first initialize the initial inventory and also set the order receipts of the period < lead time to be zero (if we order now, the earliest arrival will be after the leadtime). You can also set the demand column too.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} initializing current inventory levels and order receipt up to t=lead\PYGZus{}time}
\PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Start\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{init\PYGZus{}inv}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{lead\PYGZus{}time}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Receipt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}

\PYG{c+c1}{\PYGZsh{} add the values to demand column from the series}
\PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{demand\PYGZus{}series}
\PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} review the result}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
     Start\PYGZus{}Inv Receipt  Demand Ending\PYGZus{}Inv Order
Week                                           
1           27       0      18        NaN   NaN
2          NaN       0      16        NaN   NaN
3          NaN     NaN      13        NaN   NaN
4          NaN     NaN      17        NaN   NaN
5          NaN     NaN      11        NaN   NaN
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now at each iteration, we need to calculate the ending inventory at \(Inv_t\) from the starting inventory from the previous period \(Inv_{t-1}\), quantity received and demand using the following flow conservation.

\sphinxAtStartPar
\(Inv_{t}\) = \(Inv_{t-1} + Receipt_{t} - Demand_{t}\)

\sphinxAtStartPar
Again, inventory can be negative if you have a backlog.

\sphinxAtStartPar
\sphinxstylestrong{Note:} please examine the following code to understand the process. It is fine if you cannot develop it from scratch. The objective of this is to show how the process/code looks like. We try to put the comments to be as explicit as possible.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} assign values to the entries of the dataframe}
\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n\PYGZus{}weeks}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} computing inventory levels at the begining and end of each period}
    \PYG{k}{if} \PYG{n}{t} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} set the Start\PYGZus{}Inv equals the inv level at the end of the previous period (Ending\PYGZus{}Inv)}
        \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Start\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Calculate inventory flow for Ending\PYGZus{}Inv of the current period}
    \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Start\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Receipt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Calculating orders and receipts for period t}
    \PYG{n}{intransit\PYGZus{}quantity} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{t}\PYG{o}{+}\PYG{n}{lead\PYGZus{}time}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Receipt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} check the intransit (outstanding) order within the leadtime}

    \PYG{k}{if} \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{+} \PYG{n}{intransit\PYGZus{}quantity} \PYG{o}{\PYGZlt{}} \PYG{n}{s\PYGZus{}min}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} if \PYGZsq{}Ending\PYGZus{}Inv\PYGZsq{} + intransit \PYGZlt{} s\PYGZus{}min in this case an order must be placed}
        \PYG{c+c1}{\PYGZsh{} create an order Q = s\PYGZus{}max \PYGZhy{} current inventory position}
        \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Order}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{s\PYGZus{}max} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{+} \PYG{n}{intransit\PYGZus{}quantity}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} check if we reach the end of dataframe, if not, we add the order receipt after the leadtime}
        \PYG{k}{if} \PYG{n}{t} \PYG{o}{+} \PYG{n}{lead\PYGZus{}time} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{index}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{o}{+}\PYG{n}{lead\PYGZus{}time}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Receipt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Order}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Order}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}   \PYG{c+c1}{\PYGZsh{} no order is placed if \PYGZsq{}Ending\PYGZus{}Inv\PYGZsq{} \PYGZgt{}= s\PYGZus{}min}
        \PYG{k}{if} \PYG{n}{t} \PYG{o}{+} \PYG{n}{lead\PYGZus{}time} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{index}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{inv\PYGZus{}dataframe}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{t}\PYG{o}{+}\PYG{n}{lead\PYGZus{}time}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Receipt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}  \PYG{c+c1}{\PYGZsh{} no orders receipt in t+leadtime periods}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now you can examine the results.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{(s,S) = (}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{s\PYGZus{}min}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{s\PYGZus{}max}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{inv\PYGZus{}dataframe}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(s,S) = ( 25 , 70 )
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
     Start\PYGZus{}Inv Receipt  Demand Ending\PYGZus{}Inv Order
Week                                           
1           27       0      18          9    61
2            9       0      16         \PYGZhy{}7     0
3           \PYGZhy{}7      61      13         41     0
4           41       0      17         24    46
5           24       0      11         13     0
6           13      46      20         39     0
7           39       0      15         24    46
8           24       0      20          4     0
9            4      46      15         35     0
10          35       0      10         25     0
11          25       0      19          6    64
12           6       0      18        \PYGZhy{}12     0
13         \PYGZhy{}12      64      12         40     0
14          40       0      13         27     0
15          27       0      13         14    56
16          14       0      14          0     0
17           0      56      19         37     0
18          37       0      19         18    52
19          18       0      20         \PYGZhy{}2     0
20          \PYGZhy{}2      52      12         38     0
21          38       0      15         23    47
22          23       0      20          3     0
23           3      47      12         38     0
24          38       0      13         25     0
25          25       0      16          9    61
26           9       0      15         \PYGZhy{}6     0
27          \PYGZhy{}6      61      17         38     0
28          38       0      17         21    49
29          21       0      20          1     0
30           1      49      15         35     0
31          35       0      19         16    54
32          16       0      15          1     0
33           1      54      13         42     0
34          42       0      13         29     0
35          29       0      14         15    55
36          15       0      16         \PYGZhy{}1     0
37          \PYGZhy{}1      55      13         41     0
38          41       0      15         26     0
39          26       0      18          8    62
40           8       0      11         \PYGZhy{}3     0
41          \PYGZhy{}3      62      13         46     0
42          46       0      11         35     0
43          35       0      15         20    50
44          20       0      15          5     0
45           5      50      18         37     0
46          37       0      12         25     0
47          25       0      16          9    61
48           9       0      17         \PYGZhy{}8     0
49          \PYGZhy{}8      61      15         38     0
50          38       0      17         21    49
51          21       0      17          4     0
52           4      49      22         31     0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip



\section{Step 3: Plotting data}
\label{\detokenize{docs/Ex_Lecture_Demo_Inventory_Sim:step-3-plotting-data}}
\sphinxAtStartPar
We can also visualize the data directly from the dataframe by taking on column.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ending\PYGZus{}Inv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} plotting inv levels}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}Axes: xlabel=\PYGZsq{}Week\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{db55e59b2579410d2e5ef3d8612a674a8984d24841a5d1dbdfad7559dfff7370}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This can be done even for more than two columns.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Receipt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ending\PYGZus{}Inv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} plotting inv and receipts and resize the plot}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}Axes: xlabel=\PYGZsq{}Week\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{df11c20f1861eea454f8669344f36aab3b7b7f8c3a71713809211ffa4abef426}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
or histogram

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}Axes: \PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{93ae2237bf31db87c5b679a55a37625a9491577b8bf1d0d270f56677691e39b4}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Step 4: Summarizing the results}
\label{\detokenize{docs/Ex_Lecture_Demo_Inventory_Sim:step-4-summarizing-the-results}}
\sphinxAtStartPar
We can also use the functions in DataFrame to summarize the results.
See \sphinxurl{https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.lt.html} for more details.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{backlog\PYGZus{}num} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{lt}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{backlog\PYGZus{}total\PYGZus{}units} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}this number is negative}
\PYG{n}{demand\PYGZus{}total} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Demand}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{order\PYGZus{}total} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Order}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{order\PYGZus{}num} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Order}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{gt}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{inv\PYGZus{}total\PYGZus{}units} \PYG{o}{=} \PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Performance of (s,S) = (}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{s\PYGZus{}min}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{s\PYGZus{}max}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{) under demand scenartio:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{demand\PYGZus{}series}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Total number of orders =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{order\PYGZus{}num}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{, Average order quantity =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{order\PYGZus{}total}\PYG{o}{/}\PYG{n}{order\PYGZus{}num}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Average inventory per week =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{inv\PYGZus{}total\PYGZus{}units}\PYG{o}{/}\PYG{n}{n\PYGZus{}weeks}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Average number of backlogged units per week =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{backlog\PYGZus{}total\PYGZus{}units}\PYG{o}{/}\PYG{n}{n\PYGZus{}weeks}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{N. backlog incidents =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{inv\PYGZus{}dataframe}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ending\PYGZus{}Inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{lt}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Service Level =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{p}{(} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{backlog\PYGZus{}num}\PYG{o}{/}\PYG{n}{n\PYGZus{}weeks}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} \PYGZpc{} of times the demand is completely fulfilled}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fill rate =}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}:.2f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{demand\PYGZus{}total} \PYG{o}{+} \PYG{n}{backlog\PYGZus{}total\PYGZus{}units}\PYG{p}{)}\PYG{o}{/}\PYG{n}{demand\PYGZus{}total}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} \PYGZpc{} of quantity fulfilled on\PYGZhy{}time}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Performance of (s,S) = ( 25 , 70 ) under demand scenartio: Scenario1
Total number of orders = 15 , Average order quantity = 54.20
Average inventory per week = 19.92
Average number of backlogged units per week = \PYGZhy{}0.75
N. backlog incidents = 7
Service Level = 86.54 \PYGZpc{}
Fill rate = 95.18 \PYGZpc{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Playing with the code:}
\label{\detokenize{docs/Ex_Lecture_Demo_Inventory_Sim:playing-with-the-code}}
\sphinxAtStartPar
You can now repeat the process above with a different demand scenario (e.g., choosing the ‘Scenario2’ or ‘Scenario3’ and vary the inventory control parameters \sphinxcode{\sphinxupquote{s\_min}} and \sphinxcode{\sphinxupquote{s\_max}} and explore the results.

\sphinxstepscope


\chapter{Demo: Bass Diffusion Model}
\label{\detokenize{docs/Ex_Bass_diffusion_full_demo:demo-bass-diffusion-model}}\label{\detokenize{docs/Ex_Bass_diffusion_full_demo::doc}}
\sphinxAtStartPar
The Bass diffusion model is a mathematical model used to predict the adoption rate of a new product over time. It is based on the idea that the rate of adoption of a new product is influenced by both external factors (like marketing and advertising) and internal factors (like word\sphinxhyphen{}of\sphinxhyphen{}mouth and social influence).

\sphinxAtStartPar
The model has several key properties:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{S\sphinxhyphen{}shaped curve:} The adoption rate typically follows an S\sphinxhyphen{}shaped curve, with a slow start, a rapid growth period, and then a gradual decline.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Diminishing returns:} As more people adopt the product, the rate of adoption slows down.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Threshold effect:} There is a threshold level of adoption above which the product becomes self\sphinxhyphen{}sustaining, and the adoption rate accelerates.

\end{itemize}

\sphinxAtStartPar
The Bass diffusion model has been widely used in marketing, economics, and sociology to predict the adoption of new products and technologies. It has also been applied to other areas, such as forecasting the spread of diseases, the adoption of new policies, and the diffusion of innovations in agriculture.

\sphinxAtStartPar
While the Bass diffusion model is a powerful tool for predicting adoption rates, it is important to note that it has limitations. For example, it assumes that all potential adopters are identical, which may not be the case in reality. Additionally, the model does not account for external factors, such as economic conditions or changes in consumer preferences, that can affect adoption rates.

\sphinxAtStartPar
Despite these limitations, the Bass diffusion model remains a valuable tool for understanding and predicting the adoption of new products. By understanding the factors that influence adoption rates, businesses can develop more effective marketing strategies and make better decisions about product development and launch.


\begin{equation*}
\begin{split}F(t) = \frac{1-e^{-(p+q)t}}{1+\frac{q}{p}e^{-(p+q)t}} \end{split}
\end{equation*}
\sphinxAtStartPar
where

\begin{itemize}
\item {} 
\sphinxAtStartPar
\(p\) is the coefficiant of innovation


\item {} 
\sphinxAtStartPar
\(q\) is the coefficient of imitation


\end{itemize}

\sphinxAtStartPar
In addition, the probability of adoption by an individual at time \(t\) which is represented by \(f(t)\) (recall that \(f(t) = \frac{d}{dt}F(t)\)) can be calculated as follows:

\sphinxAtStartPar
\$\(f(t) = \frac{d}{dt}F(t) = \frac{e^{((p+q)t)}p(p+q)^2}{[pe^{((p+q)t)}+q]^2} \)\$.

\sphinxAtStartPar
Consequently, the estimated number of adoptions in each period can be calculated as  \(s(t) = m\times f(t)\)



\sphinxAtStartPar
We have then prepared the following two functions to calculate \(F(t)\) and \(f(t)\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k}{def} \PYG{n+nf}{Bass\PYGZus{}cumulative\PYGZus{}probability\PYGZus{}Ft}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{p}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{p}{(}\PYG{n}{q}\PYG{o}{/}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{p}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{Bass\PYGZus{}probability\PYGZus{}ft}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{p}{(}\PYG{n}{p}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n}{p}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{n}{math}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{p}{(}\PYG{n}{p}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{n}{t}\PYG{p}{)}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Based on the values of \(p\), \(q\) and \(m\) of the quarterly sales of iPhone provided in the code cell below, please compute the values of the estimated probability of adoption \(f(t)\), cumulative probability of adoption \(F(t)\), the number of adoptions \(s(t) = m\times f(t)\), and cumulative number of adoptions \(S(t) = m\times F(t)\) for each quarter, which is indexed by \(t\). Note that the first column below is an index whereas the subsequent four columns contain the corresponding values of the estimations based on Bass diffusion model.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Quarter\_Index
&\sphinxstyletheadfamily 
\sphinxAtStartPar
ft
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Ft
&\sphinxstyletheadfamily 
\sphinxAtStartPar
st
&\sphinxstyletheadfamily 
\sphinxAtStartPar
St
\\
\hline
\sphinxAtStartPar
…
&
\sphinxAtStartPar
…
&
\sphinxAtStartPar
…
&
\sphinxAtStartPar
…
&
\sphinxAtStartPar
…
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Regression for Bass parameters estimation}
\label{\detokenize{docs/Ex_Bass_diffusion_full_demo:regression-for-bass-parameters-estimation}}
\sphinxAtStartPar
\sphinxstylestrong{Estimating Bass diffusion model parameters}

\sphinxAtStartPar
We can now complete the Bass diffusion model pipeline by first estimating the parameters \(p\), \(q\) and \(m\) from the data prior to performing prediction. First we load the modules which are required as well as the actual data of sales of iPhone. The regression model for parameters estimation is presented in the paper below (Section “Discrete Analogue”).

\sphinxAtStartPar
Reference: Bass, F. M. (1969). A new product growth for model consumer durables. Management science, 15(5), 215\sphinxhyphen{}227.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{sklearn}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n}{url} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{https://raw.githubusercontent.com/acedesci/scanalytics/master/EN/S04\PYGZus{}Data\PYGZus{}Structures\PYGZus{}2/iphone\PYGZus{}quarter\PYGZus{}sales.csv}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{actual\PYGZus{}sales} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{url}\PYG{p}{,} \PYG{n}{index\PYGZus{}col}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Quarter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{actual\PYGZus{}sales}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
         Sales
Quarter       
0        0.270
1        1.119
2        2.315
3        1.703
4        0.717
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We would first determine the coefficients for the Bass diffusion model in order to perform the prediction as seen in the previous session. The Bass model in a basic form, can be written as:

\sphinxAtStartPar
\(s(t) = pm + (q-p)S(t) - \frac{q}{m}S(t)^2\)

\sphinxAtStartPar
which can be solved by a regression function. Here we will use the following equation (note that we do not shift one period like in the paper since the period is a bit long).

\sphinxAtStartPar
\(s(t) = a + bS(t) + cS(t)^2\)

\sphinxAtStartPar
Correspondingly, we can obtain \(m = \frac{-b \pm \sqrt{b^2-4ac}}{2c}\) (\(m\) must be positive), \(p = a/m\) and \(q = -mc\) (for the detailed proof, you can review the Section “Discrete Analogue” in the paper).

\sphinxAtStartPar
In the steps below, we demonstrate how this can be done using the linear regression model.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{input} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} we need to prepare the inputs from sales by taking the cumulative sum up until period T \PYGZhy{} 1}

\PYG{n+nb}{input}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sales}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{actual\PYGZus{}sales}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sales}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n+nb}{input}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cumulative\PYGZus{}sales}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cumsum}\PYG{p}{(}\PYG{n}{actual\PYGZus{}sales}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sales}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{input}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cumulative\PYGZus{}sales\PYGZus{}sq}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{input}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cumulative\PYGZus{}sales}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
         sales  cumulative\PYGZus{}sales  cumulative\PYGZus{}sales\PYGZus{}sq
Quarter                                              
0        0.270             0.270             0.072900
1        1.119             1.389             1.929321
2        2.315             3.704            13.719616
3        1.703             5.407            29.235649
4        0.717             6.124            37.503376
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we can use linear regression to determine \(a\), \(b\) and \(c\) of the regression function above.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cumulative\PYGZus{}sales}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cumulative\PYGZus{}sales\PYGZus{}sq}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sales}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{reg} \PYG{o}{=} \PYG{n}{sklearn}\PYG{o}{.}\PYG{n}{linear\PYGZus{}model}\PYG{o}{.}\PYG{n}{LinearRegression}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{intercept: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{reg}\PYG{o}{.}\PYG{n}{intercept\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coefficients: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{reg}\PYG{o}{.}\PYG{n}{coef\PYGZus{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{a} \PYG{o}{=} \PYG{n}{reg}\PYG{o}{.}\PYG{n}{intercept\PYGZus{}}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{reg}\PYG{o}{.}\PYG{n}{coef\PYGZus{}}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{reg}\PYG{o}{.}\PYG{n}{coef\PYGZus{}}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
intercept: 3.6726987894801724
coefficients: [ 1.15612351e\PYGZhy{}01 \PYGZhy{}6.23837858e\PYGZhy{}05]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Following the results, we can obtain

\sphinxAtStartPar
\(m = \frac{-b \pm \sqrt{b^2-4ac}}{2c}\)

\sphinxAtStartPar
and \(m\) (the size of potential customer base) must be positive.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} determine m}
\PYG{n}{m1} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}
\PYG{n}{m2} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{m1}\PYG{p}{,}\PYG{n}{m2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{m1 = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{m1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{, m2 = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{m2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{m = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
m1 =  \PYGZhy{}31.24072191263632 , m2 =  1884.4843034859591 m =  1884.4843034859591
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Then, we can directly obtain \(p = a/m\) and \(q = -mc\) for the Bass diffusion model.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{a}\PYG{o}{/}\PYG{n}{m}
\PYG{n}{q} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{o}{*}\PYG{n}{c}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{m = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{, p = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
m =  1884.4843034859591 , p =  0.0019489145028623142 q =  0.11756126506137607
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Below are some examples of how different outputs can be generated by the Bass diffusion model.

\sphinxAtStartPar
\sphinxstylestrong{Question 1}: Please compute the values as indicated in the table above for the first 40 quarters of the sales (i.e., 10 years) using the parameters provided. The index of the quarter must be from \(0 \rightarrow 39\) (i.e., the first quarter is considered period \(t=0\)).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{n}{column\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{st}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{St}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{quarter\PYGZus{}index} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{bass\PYGZus{}df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{n}{index} \PYG{o}{=} \PYG{n}{quarter\PYGZus{}index}\PYG{p}{,} \PYG{n}{columns} \PYG{o}{=} \PYG{n}{column\PYGZus{}names}\PYG{p}{)}
\PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{index}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Quarter}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} start your code here \PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Bass\PYGZus{}probability\PYGZus{}ft}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Bass\PYGZus{}cumulative\PYGZus{}probability\PYGZus{}Ft}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{n}{t}\PYG{p}{)} \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{st}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{m}\PYG{o}{*}\PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{at}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{St}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{m}\PYG{o}{*}\PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{at}\PYG{p}{[}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} end your code here \PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{n}{bass\PYGZus{}df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               ft        Ft         st           St
Quarter                                            
0        0.001949  0.000000   3.672699     0.000000
1        0.002187  0.002066   4.121845     3.893112
2        0.002453  0.004384   4.623538     8.261201
3        0.002751  0.006983   5.183301    13.159540
4        0.003082  0.009896   5.807073    18.649135
5        0.003450  0.013159   6.501194    24.797131
6        0.003859  0.016809   7.272376    31.677206
7        0.004313  0.020892   8.127653    39.369912
8        0.004815  0.025452   9.074300    47.962967
9        0.005370  0.030540  10.119730    57.551440
10       0.005981  0.036210  11.271350    68.237826
11       0.006652  0.042522  12.536367    80.131944
12       0.007387  0.049536  13.921550    93.350623
13       0.008189  0.057319  15.432937   108.017124
14       0.009061  0.065939  17.075473   124.260231
15       0.010004  0.075465  18.852590   142.212953
16       0.011019  0.085971  20.765728   162.010779
17       0.012106  0.097528  22.813792   183.789418
18       0.013262  0.110206  24.992575   207.681977
19       0.014484  0.124074  27.294161   233.815550
20       0.015764  0.139193  29.706331   262.307214
21       0.017093  0.155618  32.212039   293.259450
22       0.018461  0.173392  34.788976   326.755096
23       0.019851  0.192547  37.409319   362.851933
24       0.021247  0.213097  40.039705   401.577141
25       0.022628  0.235036  42.641499   442.921864
26       0.023970  0.258339  45.171429   486.836225
27       0.025250  0.282955  47.582589   533.225157
28       0.026440  0.308809  49.825855   581.945444
29       0.027515  0.335797  51.851650   632.804359
30       0.028449  0.363792  53.611996   685.560219
31       0.029219  0.392641  55.062732   739.925081
32       0.029804  0.422168  56.165740   795.569684
33       0.030189  0.452182  56.890996   852.130535
34       0.030363  0.482476  57.218267   909.218892
35       0.030320  0.512836  57.138295   966.431192
36       0.030063  0.543045  56.653351  1023.360364
37       0.029598  0.572893  55.777094  1079.607339
38       0.028938  0.602176  54.533767  1134.792093
39       0.028101  0.630710  52.956791  1188.563574
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Question 2}: Please (i) plot the columns \sphinxcode{\sphinxupquote{{[}'ft','Ft'{]}}} in a single plot using line plot (parameter \sphinxcode{\sphinxupquote{kind='line'}}) and (ii) plot the columns \sphinxcode{\sphinxupquote{{[}'st','St'{]}}} in a single plot using bar plot (parameter \sphinxcode{\sphinxupquote{kind='bar'}}). You can also indicate the plot size using the parameter \sphinxcode{\sphinxupquote{figsize = (12,4)}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} start your code here \PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{figsize} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{st}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{St}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{kind} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{figsize} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} end your code here \PYGZsh{}\PYGZsh{}\PYGZsh{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}Axes: xlabel=\PYGZsq{}Quarter\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{9da4dc4e3a3d5ebe4ca34c277a63ecb5ea47eea75d2872b8cc204615e0b3f081}.png}

\noindent\sphinxincludegraphics{{88b2a13d729e5bfae609ce26eef85d439475ebc7458007a74a8e0702b7e6226c}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now we can compare the results with the actual quarterly sales of iPhone for the first 40 quarters (starting from Q2 2007 which the product was first introduced).

\sphinxAtStartPar
\sphinxstylestrong{Question 3}: Please add the following columns and their corresponding values to the \sphinxcode{\sphinxupquote{bass\_df}} DataFrame
\begin{itemize}
\item {} 
\sphinxAtStartPar
Column \sphinxcode{\sphinxupquote{'Actual'}}: which contains the actual sales from the DataFrame \sphinxcode{\sphinxupquote{actual\_sales}}

\item {} 
\sphinxAtStartPar
Column \sphinxcode{\sphinxupquote{'CumulativeActual'}}: which calculates the sum from the first quarter up until each quater in the index

\item {} 
\sphinxAtStartPar
Column \sphinxcode{\sphinxupquote{'PError'}}: which calculates the percentage error of each corresponding quarter from column \sphinxcode{\sphinxupquote{'Actual'}} and column \sphinxcode{\sphinxupquote{'st'}} (estimated sales in each quarter), i.e., \sphinxcode{\sphinxupquote{PError = (Actual\sphinxhyphen{}st)/Actual}}

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} start your code here \PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Actual}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{actual\PYGZus{}sales}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sales}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CumulativeActual}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{actual\PYGZus{}sales}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{:}\PYG{n}{t}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sales}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n}{actual\PYGZus{}sales}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sales}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{]}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PError}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Actual}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{st}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Actual}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} end your code here \PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{bass\PYGZus{}df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               ft        Ft         st           St  Actual  CumulativeActual  \PYGZbs{}
Quarter                                                                         
0        0.001949  0.000000   3.672699     0.000000   0.270             0.270   
1        0.002187  0.002066   4.121845     3.893112   1.119             1.389   
2        0.002453  0.004384   4.623538     8.261201   2.315             3.704   
3        0.002751  0.006983   5.183301    13.159540   1.703             5.407   
4        0.003082  0.009896   5.807073    18.649135   0.717             6.124   
5        0.003450  0.013159   6.501194    24.797131   6.892            13.016   
6        0.003859  0.016809   7.272376    31.677206   4.363            17.379   
7        0.004313  0.020892   8.127653    39.369912   3.793            21.172   
8        0.004815  0.025452   9.074300    47.962967   5.208            26.380   
9        0.005370  0.030540  10.119730    57.551440   7.367            33.747   
10       0.005981  0.036210  11.271350    68.237826   8.737            42.484   
11       0.006652  0.042522  12.536367    80.131944   8.752            51.236   
12       0.007387  0.049536  13.921550    93.350623   8.398            59.634   
13       0.008189  0.057319  15.432937   108.017124  14.102            73.736   
14       0.009061  0.065939  17.075473   124.260231  16.235            89.971   
15       0.010004  0.075465  18.852590   142.212953  18.647           108.618   
16       0.011019  0.085971  20.765728   162.010779  20.338           128.956   
17       0.012106  0.097528  22.813792   183.789418  17.073           146.029   
18       0.013262  0.110206  24.992575   207.681977  37.044           183.073   
19       0.014484  0.124074  27.294161   233.815550  35.064           218.137   
20       0.015764  0.139193  29.706331   262.307214  26.028           244.165   
21       0.017093  0.155618  32.212039   293.259450  26.910           271.075   
22       0.018461  0.173392  34.788976   326.755096  47.789           318.864   
23       0.019851  0.192547  37.409319   362.851933  37.430           356.294   
24       0.021247  0.213097  40.039705   401.577141  31.241           387.535   
25       0.022628  0.235036  42.641499   442.921864  33.797           421.332   
26       0.023970  0.258339  45.171429   486.836225  51.025           472.357   
27       0.025250  0.282955  47.582589   533.225157  43.719           516.076   
28       0.026440  0.308809  49.825855   581.945444  35.203           551.279   
29       0.027515  0.335797  51.851650   632.804359  39.272           590.551   
30       0.028449  0.363792  53.611996   685.560219  74.468           665.019   
31       0.029219  0.392641  55.062732   739.925081  61.170           726.189   
32       0.029804  0.422168  56.165740   795.569684  47.534           773.723   
33       0.030189  0.452182  56.890996   852.130535  48.050           821.773   
34       0.030363  0.482476  57.218267   909.218892  74.780           896.553   
35       0.030320  0.512836  57.138295   966.431192  51.200           947.753   
36       0.030063  0.543045  56.653351  1023.360364  40.399           988.152   
37       0.029598  0.572893  55.777094  1079.607339  45.513          1033.665   
38       0.028938  0.602176  54.533767  1134.792093  78.290          1111.955   
39       0.028101  0.630710  52.956791  1188.563574  50.763          1162.718   

            PError  
Quarter             
0       \PYGZhy{}12.602588  
1        \PYGZhy{}2.683508  
2        \PYGZhy{}0.997209  
3        \PYGZhy{}2.043629  
4        \PYGZhy{}7.099125  
5         0.056704  
6        \PYGZhy{}0.666829  
7        \PYGZhy{}1.142803  
8        \PYGZhy{}0.742377  
9        \PYGZhy{}0.373657  
10       \PYGZhy{}0.290071  
11       \PYGZhy{}0.432400  
12       \PYGZhy{}0.657722  
13       \PYGZhy{}0.094379  
14       \PYGZhy{}0.051769  
15       \PYGZhy{}0.011025  
16       \PYGZhy{}0.021031  
17       \PYGZhy{}0.336250  
18        0.325327  
19        0.221590  
20       \PYGZhy{}0.141322  
21       \PYGZhy{}0.197029  
22        0.272030  
23        0.000553  
24       \PYGZhy{}0.281640  
25       \PYGZhy{}0.261695  
26        0.114720  
27       \PYGZhy{}0.088373  
28       \PYGZhy{}0.415387  
29       \PYGZhy{}0.320321  
30        0.280067  
31        0.099841  
32       \PYGZhy{}0.181591  
33       \PYGZhy{}0.183996  
34        0.234845  
35       \PYGZhy{}0.115982  
36       \PYGZhy{}0.402345  
37       \PYGZhy{}0.225520  
38        0.303439  
39       \PYGZhy{}0.043216  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
We can also generate the date of the last day of each quarter using the code below. This list will be later used as new indexes.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{quarter\PYGZus{}index\PYGZus{}date} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{date\PYGZus{}range}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{4/1/2007}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{periods}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{freq}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{quarter\PYGZus{}index\PYGZus{}date}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
DatetimeIndex([\PYGZsq{}2007\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2007\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2007\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2008\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2008\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2008\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2008\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2009\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2009\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2009\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2009\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2010\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2010\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2010\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2010\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2011\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2011\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2011\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2011\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2012\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2012\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2012\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2012\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2013\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2013\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2013\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2013\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2014\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2014\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2014\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2014\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2015\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2015\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2015\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2015\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2016\PYGZhy{}03\PYGZhy{}31\PYGZsq{},
               \PYGZsq{}2016\PYGZhy{}06\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2016\PYGZhy{}09\PYGZhy{}30\PYGZsq{}, \PYGZsq{}2016\PYGZhy{}12\PYGZhy{}31\PYGZsq{}, \PYGZsq{}2017\PYGZhy{}03\PYGZhy{}31\PYGZsq{}],
              dtype=\PYGZsq{}datetime64[ns]\PYGZsq{}, freq=\PYGZsq{}Q\PYGZhy{}DEC\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{Question 4}: Please (i) replace the original indexes using the newly created list \sphinxcode{\sphinxupquote{quarter\_index\_date}} and (ii) then create the following plots from the DataFrame \sphinxcode{\sphinxupquote{bass\_df}} using the size \sphinxcode{\sphinxupquote{figsize=(12,4)}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Columns \sphinxcode{\sphinxupquote{{[}'St','CumulativeActual'{]}}} using a line plot

\item {} 
\sphinxAtStartPar
Columns \sphinxcode{\sphinxupquote{{[}'st','Actual'{]}}} using a line plot

\item {} 
\sphinxAtStartPar
Column \sphinxcode{\sphinxupquote{{[}'PError'{]}}} using a bar plot

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Hint}: you can use the method \sphinxcode{\sphinxupquote{.set\_index(...)}} by calling \sphinxcode{\sphinxupquote{bass\_df =  bass\_df.set\_index(new\_index\_list)}} to set the index (see \sphinxhref{https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.set\_index.html}{link})

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} start your code here \PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{bass\PYGZus{}df} \PYG{o}{=} \PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{set\PYGZus{}index}\PYG{p}{(}\PYG{n}{quarter\PYGZus{}index\PYGZus{}date}\PYG{p}{)}
\PYG{n}{bass\PYGZus{}df}\PYG{o}{.}\PYG{n}{index}\PYG{o}{.}\PYG{n}{names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Quarter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{St}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CumulativeActual}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{st}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Actual}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{bass\PYGZus{}df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PError}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} end your code here \PYGZsh{}\PYGZsh{}\PYGZsh{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}Axes: xlabel=\PYGZsq{}Quarter\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{97b18dee6e0bd4b4d0192d9422deb24c3b2de1618854f92470b8131511e03442}.png}

\noindent\sphinxincludegraphics{{0f64380aec495dc1fdaf2b45c1e66b583f03d137402c87cb42af343e1dba62fe}.png}

\noindent\sphinxincludegraphics{{0feb4d7eebb43d47e86d07685ae6dd90aa18c6349d95b0aac711ac291f5c93c4}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}






\renewcommand{\indexname}{Index}
\printindex
\end{document}